---
title: 'Lab 3: Optimal Harvest'
author: "your name here"
date: "23 January 2025"
output: 
  html_document:
    toc: true
    toc_float: true  # Optional, makes the TOC float on the side
---

# Important Deadlines

##### Important checkpoints
    
* **Week 4 (Wednesday, January 29 by 11:59 PM)**: Identify your partners for your final project.

* **Week 5 (Tuesday, February 4 by 11:59 PM)**: Paper selection (first choice and alternate) on this google sheet (https://docs.google.com/spreadsheets/d/1vcWsQ1MsTFamkS7lli94J-wor0p8dbMePD17rWS304s/edit?gid=0#gid=0) -- make sure to navigate to your section's tab!  

* **Week 5 (Thursday, February 6)**: IN LAB: Appointments with Dr. Moeller and Caitlin in lab about your paper choices. We expect you to -- (1) have read both papers, and (2) explain to us why you have chosen this paper (For example -- What interests you about it? What ecological concept(s) does this paper address? Which portion will you analytically develop during your presentation? What time series simulation will you code up (and vary a parameter for) in your written report?). Refer to the Project guidelines on Canvas for more details!  

Don't have a group yet? Talk to each other today AND put yourself in the "Group Selection List" on the google sheet below (use the tab for your section!)

# Bifurcation diagram

Remember that this is a figure where the stable equilibrium population size (N*) is plotted as a function of some parameter. In this case, let's make a bifurcation diagram for the logistic growth model of population growth, with stable equilibrium population size as a function of carrying capacity K.

To do this in R, you'll have to make a nested for() loop. You'll basically tell R:  
1. Create a vector of different values for your parameter (x-axis of the bifurcation diagram)  
2. Calculate the N* for each parameter - do this by calculating population size, then pull out the last value of N (ASSUMPTION: N will reach equilibrium at the end of the simulation)  
3. Store the N* (y-axis of the bifurcation diagram)  

Here's an example of how that works. Let's make a bifurcation diagram of N* as a function of K for the logistic growth model.
```{r}
######################################################
# 0. some set up of variables
######################################################
r <- 0.5

######################################################
# 1. create a vector of different values for K
######################################################
Kset <- seq(from = 1, to = 100, by = 1)


######################################################
# 2. calculate N* for each parameter value
######################################################
## 2a. create a holding vector for N*
Nstarset <- rep(NaN, times = length(Kset))

## 2b. create a sequence of timepoints at which to calculate population size (in the inner for() loop)
timepoints <- seq(from = 1, to = 25, length = 1000)

## 2b. write a for() loop 
### nested for() loop structure:
#### outer loop: choose a value of K from Kset
##### inner loop: calculate population size at every time step
#### outer loop: pull out the last population size (N*) and store it in Nstarset

# this is the start of the outer loop!
# for each element j from the first to last in Kset
for(j in 1:length(Kset)) {
  
  # assign K the value from Kset for this iteration
  K <- Kset[j]
  
  # create a holding vector for the inner loop for population sizes
  N.simu <- rep(NaN, times = length(timepoints)) 
  # set your initial condition
  N.simu[1] <- 10
  
  # inner loop: calculate population size (N)
  # for each element i from the second to the last in timepoints
  for(i in 2:length(timepoints)){ 
    # store previous population size as N
    N <- N.simu[i-1]
    
    # calculate change in time
    deltat <- timepoints[i] - timepoints[i-1] 

    # calculating the change in population size from logistic growth fxn 
    deltaN <- N * r * (1 - N / K) * deltat 
    
    # calculating total population size
    N.simu[i] = N + deltaN
  }
  
  ######################################################
  # 3. store the N* (back in the outer loop)
  ######################################################
  # pull out the last value from N.simu and put it in Nstarset
  Nstarset[j] <- N.simu[length(timepoints)] 
  
}
```

```{r}
plot(x = Kset, y = Nstarset, 
     type='l', #line
     lwd=2, #line weight
     xlab = "Carrying Capacity, K", #x axis label
     ylab = "Stable Equilibria of Popn Size, N*") #y axis label
```

# 1. Modeling a logistically growing population

Before starting in on optimal harvest, let's review how to model a logistically growing population. We learned how to do this in last week's lab when we measured bacterial growth.  

## a. Modelling using a given set of parameters

First, we can assign parameters. Let's say that for this population, $r = 0.5$ and $K = 100$.
```{r}
r <- 0.5 # growth rate
K <- 100 # carrying capacity
```

Then, we can simulate that population's growth over time using a `for()` loop. Recall that $\frac{dN}{dt} = rN(1-\frac{N}{K})$. What are the 3 components necessary for a successful `for()` loop?
```{r}
#################################
# 1. designate a data vector
#################################
tset <- seq(from = 0, to = 100, length.out = 20000) # create a sequence of numbers from 0 to 100 that is 20000 values long


#################################
# 2. create a holding vector (building 3 empty boxes)
#################################
N.simu <- NaN * tset # create a vector of NaNs that is the same length as tset
N0 <- 2 # assign 2 to N0
N.simu[1] <- N0 # fill in initial conditions

#################################
# 3. the for() loop
#################################
# for each element i from the second to the last element in tset
for(i in 2:length(tset)){ 
  # calculate change in time: this timestep - previous timestep
  dt <- tset[i] - tset[i-1] 
  
  # calculate change in population size
  dNdt <- (r * N.simu[i-1] * (1-N.simu[i-1]/K)) * dt 
  
  # calculate total population size and put into holding vector
  N.simu[i] <- N.simu[i-1] + dNdt 
}
```

Check the output of your `for()` loop in the console to make sure it looks like what you would expect. Now we can plot. What do each of the arguments mean?
```{r}
plot(x = tset, y = N.simu, # x and y axes
     type = 'l', # linear line
     ylim = c(0, 1.1*K), # limit on y-axis
     las = 1, # horizontal axis labels
     lwd = 2, # line width
     xlab = 'Time', # x-axis label
     ylab = 'Population Size') # y-axis label
```

## b. Changing initial population size

What if we change the initial population size? We can run additional simulations where $N_0 = 50, 100, 150$ and overlay them on your timeseries plot.
```{r}
#################################
# 1. designate your data
#################################
# this has already been done; we're using tset


#################################
# 2. create a holding vector
#################################
# N0 = 50
N0.50 <- 50
N.simu.50 <- NaN*tset
N.simu.50[1] <- N0.50

# N0 = 100
N0.100 <- 100
N.simu.100 <- NaN*tset
N.simu.100[1] <- N0.100

# N0 = 150
N0.150 <- 150
N.simu.150 <- NaN*tset
N.simu.150[1] <- N0.150

# Tip: You can run these calculations simultaneously within your for loop, but be very careful to keep track of which variable is which!


#################################
# 3. the for() loop
#################################
# for each element i from the second to the last element in tset
for(i in 2:length(tset)){
  # calculate change in time
  dt <- tset[i] - tset[i-1]
  
  # calculate change in population size and total population size if N0 = 50
  dNdt.50 <- (r*N.simu.50[i-1]*(1-N.simu.50[i-1]/K))*dt
  N.simu.50[i] <- N.simu.50[i-1] + dNdt.50
  
  # calculate change in population size and total population size if N0 = 100
  dNdt.100 <- (r*N.simu.100[i-1]*(1-N.simu.100[i-1]/K))*dt
  N.simu.100[i] <- N.simu.100[i-1] + dNdt.100
  
  # calculate change in population size and total population size if N0 = 150
  dNdt.150 <- (r*N.simu.150[i-1]*(1-N.simu.150[i-1]/K))*dt
  N.simu.150[i] <- N.simu.150[i-1] + dNdt.150
}
```

To overlay these on our original plot, we can use sequential 'line' commands. As in the last lab, the `col` argument chooses a colour for each line. For a list of some colour selections available in R, consult the [list](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf). The `rgb()` function is also capable of specifying colours from three RGB arguments (and can also take a fourth input parameter specifying transparency), when you want to get really fancy.  

**Note:** When running this in R Markdown, unfortunately the chunk has to be run all at once (using the 'play' button, or by highlighting and executing simultaneously). Otherwise, the program "forgets" which plot it's on and gives an error when you try to add a line.
```{r}
###########################################
# 1. plot the simulated population sizes
###########################################
plot(x = tset, y = N.simu, 
     type = 'l', #line
     ylim = c(0, 1.6*K), #(go 1.6 times carrying capacity away from the value of k)
     las = 1, 
     lwd = 2, 
     xlab = 'Time',
     ylab = 'Population Size')
# what happens if we don't change the limits on the y-axis?

######################################################
# 2. plot the lines for different initial conditions
######################################################
# N0 = 50
lines(tset, N.simu.50, 
      col = 'paleturquoise3',
      lwd = 2)
# N0 = 100
lines(tset, N.simu.100,
      col = 'peachpuff3',
      lwd = 2)
# N0 = 150
lines(tset, N.simu.150, 
      col = 'coral2',
      lwd = 2)

######################
# 3. add a legend
######################
# this makes it easier to keep track of each line!
legend(x = max(tset)*.6, y = 1.6*K, 
       lwd = 2, #thickness of text
       legend = c('N0=2','N0=50','N0=100','N0=150'), #order for naming legend 
       col = c('black','paleturquoise3','peachpuff3','coral2'), #in order matching legend name
       horiz = FALSE)

# what do each of these arguments mean?
```

## c. dN/dt as a function of N

We can also plot $\frac{dN}{dt}$ as a function of N, akin to the plots you've been seeing in lecture that examine how a population's growth depends on its current size. First, let's generate a range of Ns for which we'd like to know the change in population size. A reasonable range would be from 0 to K, but let's go a bit past K so that we can see where $\frac{dN}{dt}$ becomes negative.
```{r}
Nset <- seq(from = 0, to = K*1.1, length.out = 200)
```

We could calculate $\frac{dN}{dt}$ using a `for()` loop, but it's more efficient to use a **vector operation**. The reason this works is that each entry of our $\frac{dN}{dt}$ storage variable depends only on N, not on an adjacent value of $\frac{dN}{dt}$. We need to use a `for()` loop for our temporal simulations because each value depends on the previous $t-1$ value of the population size.
```{r}
dNdt.log <- r * Nset * (1-Nset/K) 

#vector multiplication (est growth rate times N times 1/k) - does this for every value of N since its a full vector
```

We can plot $\frac{dN}{dt}$ vs $N$ and check to see if this makes sense.
```{r}
############################################
# 1. plot dN/dt as a function of Nset
############################################
plot(x = Nset, y = dNdt.log, #x is all values of N; y is dNdt logistic
     type = 'l', #plot line
     las = 1, #specifications
     lwd = 2, 
     xlab = 'N', ylab = 'dN/dt') #axis labels


############################################
# 2. add a line along the x-axis
############################################
abline(h = 0,lwd = 1) #horizontal line

############################################
# 3. mark the equilibria where dN/dt = 0
############################################
# We'll use filled points to indicate stable equilibria, and open points to indicate unstable ones
# this is our unstable equilibrium
points(x = 0, y = 0, #location of point in x y plane 
       pch = 21, # 'pch' specifies the point shape
       cex = 1.5) # cex is a multiplier that specifies the point size
# this is our stable equilibrium
points (x = K, y = 0, 
        pch = 21, 
        cex = 1.5, 
        bg = 'black') # 'bg' specifies the fill colour of the point

############################################
# 4. add a legend
############################################
legend(x = 0, y = -1, 
       legend = c('dN/dt', 'unstable equil.', 'stable equil.'), #words
       lwd = c(2, NaN, NaN), #if they are lines or not (2 is line thickness)
       pch = c(NaN, 21, 21), #shape for circlies
       pt.cex = 1.5, 
       pt.bg = c('white', 'white', 'black')) #fill for shapes
```

# 2. Modeling harvest of a logistically growing population

## a. Population change as a function of population size

Let's employ the coding tools that we've learned (simulating and differentiating between population dynamics; finding and labeling equilibria) to consider what would happen if we harvested this population. Our model is
$\frac{dN}{dt} = rN(1-\frac{N}{K})-qEN$
where $q$ is the catchability coefficient and $E$ is the fishing effort. We'll use the same values of r and K as before ($r = 0.5$ and $K = 100$) and set $q = 0.1$ and $E = 1$.
```{r}
q <- 0.1 #catchability coeff
E <- 1 #Effort
```

Also, just to make sure we're understanding this correctly, we're going to make a new vector for population growth under a logistic growth model. It's going to be the exact same as `dNdt.log`, but we'll rename this so that it's less confusing down the line.
```{r}
growth.log <- dNdt.log
```


First, plot the rate of population change as a function of population size. **Note:** we must be careful of our y-axis labels now because $\frac{dN}{dt}$ has two components: 1. the biology of logistic growth, and 2. the economics of harvest.
```{r}
############################################
# 1. plot the biology of logistic growth
############################################
# plot the biology in black
plot(x = Nset, y = growth.log, #x is all values of N, y is growth rate change
     type = 'l', #line type
     las = 1, #line specifics
     lwd = 2, #line thickness
     xlab = 'N', ylab = 'Population Change') #label axes

# plot the x-axis so that it's easier to see the intercept
abline(h = 0, lwd = 1)

############################################
# 2. plot the economics of harvest
############################################
# plot the economics in blue
lines(x = Nset, y = (q*E*Nset), col = 'royalblue2', lwd = 2) #harvest equation with q = 0.1 and E = 1

############################################
# 3. create a legend
############################################
legend(x = 0, y = -1, #coordinates for legend
       lwd = c(2, 2), #types of lines for each part of the legend
       legend = c('growth', 'harvest'), #labels for legend in order
       col = c('black', 'royalblue2')) #colors for legend in order 
```

We'd now like to find the equilibria (the intersections of the black and blue lines). One (unstable) is at $N = 0$. The other is somewhere between 0 and K. There are two ways to find this equilibrium:  
1. **Algebraically**, by solving $\frac{dN}{dt} = 0$  
2. **By simulation**, by using a `for()` loop  

We can start with the algebraic solution.
```{r}
Nstar <- K*(1-q*E/r)  # Check this with pen (or pencil) and paper!
Nstar
```

Now, we can try the simulation. What 3 components do you need for a successful `for()` loop?
```{r}
#################################
# 1. designate the data vector
#################################
tset <- seq(from = 0, to = 100, length.out = 20000) 

#################################
# 2. create a holding vector
#################################
N.simu.E1 <- NaN*tset #create empty box/holding vector
N.simu.E1[1] <- N0 #set initial condition

#################################
# 3. the for() loop
#################################
for(i in 2:length(tset)){ #iterate over the timeseries in 2 b/c initial conditionas
  dt <- tset[i] - tset[i-1] #change in time
  dNdt.E1 <- (r*N.simu.E1[i-1]*(1-N.simu.E1[i-1]/K)-q*E*N.simu.E1[i-1])*dt #change in pop equilibrium 1 - this is equation for harvest
  N.simu.E1[i] <- N.simu.E1[i-1] + dNdt.E1 #add change in this timestep to pop size beforehand
}
```

After checking the output of your `for()` loop, you can plot it.
```{r}
plot(x = tset, y = N.simu.E1, #
     type = 'l', 
     lwd = 2, 
     xlab = 'Time', ylab = 'Population Size')
```

## b. Yield as a function of time

Recall that $Y = qEN$.
```{r}
############################################
# 1. plot logistic growth in black
############################################
plot(x = tset, y = N.simu.E1, 
     type = 'l', lwd = 2, 
     xlab = 'Time', ylab = 'Population Size')

############################################
# 2. plot yield in blue
############################################
lines(x = tset, y = N.simu.E1*E*q, 
      type = 'l', 
      lwd=2, 
      col='royalblue2')

############################################
# 3. add a legend
############################################
legend(x = max(tset)*.6, y = max(N.simu.E1)*.5, 
       lwd = c(2, 2), 
       legend = c('Population', 'Yield'), 
       col = c('black', 'royalblue2'))
```

## c. Comparing solutions

We can compare our algebraic solution with our simulation solution.
```{r}
Nstar # our algebraic solution
N.simu.E1[length(tset)] # the end population size of our simulation - index the last value (specifying length tset).
```

## d. Equilibrium yield

Now that we have confidence in our equilibrium population size, we can calculate the equilibrium yield.
```{r}
Ystar <- q*E*Nstar #what is our yeild at equilirbium ? 
Ystar
```

As a final check, we can add this point to our plot and make sure it falls on the intersection of the blue and black lines.
```{r}
################################################
# 1. plot population growth as a function of N
################################################
plot(x = Nset, y = growth.log, 
     type = 'l', 
     las = 1, 
     lwd = 2, 
     xlab = 'N', ylab = 'Population Change', main = 'log')

# add a line at the x-axis
abline(h = 0, lwd = 1)

################################################
# 2. plot the economics of harvest
################################################
lines(x = Nset, y = q*E*Nset, #linear line
      col = 'royalblue2', 
      lwd = 2)

################################################
# 3. add equilibria
################################################
# unstable
points(x = 0, y = 0, 
       pch = 21, cex = 1.5)
# stable
points(y = Ystar, x = Nstar, 
       pch = 21, cex = 1.5, 
       bg = 'black')

################################################
# 4. add a legend
################################################
legend(x = 0, y = -0.5, 
       legend = c('growth', 'harvest', 'unstable equil.', 'stable equil.'), 
       lwd = c(2, 2, NaN, NaN), 
       pch = c(NaN, NaN, 21, 21), 
       pt.cex = 1.5, 
       pt.bg = c('white', 'white', 'white', 'black'), 
       col = c('black', 'royalblue2', 'black', 'black'),
       ncol = 2)
```

# 3. Examining how effort changes yield

We now know that for a fishing effort E = 1, we are catching 8 fish (yield) at equilibrium. But could we do better? Let's alter E and see how it affects yield. We'll plot lines for a few different values of E.  

```{r}
################################################
# 1. plot population growth as a function of N
################################################
plot(x = Nset, y = growth.log, 
     type = 'l', 
     las = 1, 
     lwd = 2, 
     xlab = 'N', ylab = 'Population Change')
abline(h = 0, lwd = 1)

# Overlay Yield given a fishing Effort = 1
lines(x = Nset, y = q*E*Nset, 
      col= 'royalblue2',
      lwd = 2)

############################
# 2. Set effort to 2
############################
# Set Effort to 2 and name this value E.2 with variable assignment 
E.2 <- 2

# Overlay Yield given a fishing Effort = 2
lines(x = Nset, y = q*E.2*Nset, #changign the object for E
      col= 'royalblue2',
      lwd = 2,
      lty = 2) #lty changes the line type. 2 = dashed 

############################
# 3. Set effort to 3
############################
# Set Effort to 3 and name this value E.3 with variable assignment 
E.3 <- 3

# Overlay Yield given a fishing Effort = 3, fill in the blank y argument
lines(x = Nset, y = q*E.3*Nset, 
      col = 'royalblue2',
      lwd = 2,
      lty = 3) 

############################
# 4. Set effort to 4
############################
# Set Effort to 4 and name this value E.4 with variable assignment 
E.4 <- 4

# Overlay Yield given a fishing Effort = 4, fill in the blank y argument
lines(x = Nset, y = q*E.4*Nset, 
      col= 'royalblue2', 
      lwd = 2,
      lty = 4) #line type

#more effort --> pulling equilibrium down
```

What have you observed about increasing E? What would happen if you decreased E below 1?

## Think Pair Share 1: Yield as a function of effort

Create a graph of yield (on the y-axis) as a function of effort (on the x-axis). First, choose a range of E values using the `seq()` function. A natural choice for lower bound is 0, but what about the upper bound? You can use your explorations above for inspiration. Also think about what we learned in class about $E = \frac{r}{q}$.
```{r}
# fill in the blank for the upper bound
Eset <- seq(from = 0, to = (r/q)*1.1, length.out = 200)

```

Then, find the associated equilibrium population size and name this variable `Nstar.set` with variable assignment. Recall that $N^* = K(1-\frac{qE}{r})$. Remember your variable assignments as you substitute in variables. 
```{r}
Nstar.set <- K*(1-q*Eset/r)
Nstar.set

```

Next, calculate the corresponding yields and name this variable `Yield.set` with variable assignment. Recall that $Y = qEN^*$.
```{r}
Yield.set <- q*Eset*Nstar.set
Yield.set

```

Finally, plot yields as a function of effort.
```{r}
plot(x = Nstar.set, y = q*Eset*Nstar.set, 
     type = 'l', 
     lwd = 2, 
     xlab = 'Effort', ylab = 'Yield')
abline(h = 0)
```


# 4. Calculating Maximum Sustainable Yield (MSY)

As managers of this population, we might like to achieve **maximum sustainable yield**. We can see from our previous graph that there is a maximum, and we can estimate from this graph the effort level where it might fall. But let's be a bit more precise. There are three ways we could calculate MSY:  

1. use the calculus/algebra approach we learned in lecture,  
2. estimate it from our graph, or  
3. guess and check.  

The third option would be quite time-consuming (even if we wrote an algorithm to do it for us), so we'll focus on the first two options.

## a. Calculus-based approach

On pen and paper, prove that $N_{MSY} = \frac{K}{2}$, $E_{MSY} = \frac{r}{2q}$, and $Y_{MSY} = \frac{rK}{4}$. Calculate their exact values for our set of parameters below.
```{r}
N_MSY <- K/2
E_MSY <- r/q/2
Y_MSY <- r*K/4

#print values
N_MSY 
E_MSY 
Y_MSY 
```

## b. Estimate from graph

First, find the effort value that produced the maximum yield. We can do this using a `for()` loop with a different application than what we usually use them for. Here, we'll estimate E and assign this value to the variable `E_MSY_est`.
```{r}
for(i in 1:length(Eset)){
  if(Yield.set[i]==max(Yield.set)){
    E_MSY_est <- Eset[i]
  }
}
```

Calculate an estimate for $N_{MSY}$ called `N_MSY_est` given your previous estimate for $E_{MSY}$. Recall the algebraic solution for $N^*$ when $\frac{dN}{dt} = 0$ (at equilibrium) as $N^* = K(1-\frac{qE}{r})$.
```{r}
N_MSY_est <- K*(1-((q*E_MSY_est)/r))
```

Then, calculate an estimate for $Y_{MSY}$ and call it `Y_MSY_est`. Use the `max()` function to calculate the maximum yield value over your range of effort values. 
```{r}
Y_MSY_est <- max(Yield.set)
```

Now, you can compare the values from the two approaches:
```{r}
#  Compare:
N_MSY # algebraic
N_MSY_est # estimate

E_MSY # algebraic
E_MSY_est # estimate

Y_MSY # algebraic
Y_MSY_est # estimate
```

How close were your two results? How might changing the length of the Eset vector alter the accuracy of your numerical (R-based) estimation?

# 5. Harvesting a stock with overcompensating recruitment

Not all populations follow the logistic equation (for a number of reasons). One commonly reported difference for fisheries is that populations may "overcompensate." What this means is that when the population is small, it may grow faster than you would expect based on strict logistic growth. Biologically, this could result from a population with a high per-capita fecundity, such that very few adults could produce a very large number of offspring in the next timestep. A convenient way to mimic this phenomenon with a mathematical model is to use the formulation:

$\frac{dN}{dt} = rN(1-\frac{N}{K})(2-\frac{N}{K})$  

The additional multiplier term has the effect of increasing the growth rate when the population is small (N << K). This is easiest to see visually.  

First, we'll calculate $\frac{dN}{dt}$ for an overcompensating population.
```{r}
dNdt.over <- r*Nset*(1-Nset/K)*(2-Nset/K) #equation for overcompensating population
```

Then, we'll plot it.

```{r}
###################################################
# 1. plot dN/dt as a function of population size
###################################################
plot(x = Nset, y = dNdt.over, 
     type = 'l', 
     lwd = 2, 
     las = 1, 
     xlab = 'N', ylab = 'dN/dt')

# add a line at the x-axis
abline(h = 0)

###################################################
# 2. plot the logistic function for comparison
###################################################
lines(x = Nset, y = dNdt.log, 
      lwd = 2, 
      lty = 3)

###################################################
# 3. add a legend
###################################################
legend(x = 73, y = 20, 
       legend = c("overcompensating", "logistic"), 
       lwd = c(2, 2), 
       lty = c(1, 3))
```

## a. Comparing logistic and overcompensating growth

We can also compare how two populations, which start at the same population size, would grow differently over time depending on which function applied to them. We'll use a `for()` loop to calculate population size over time for an overcompensating population.
```{r}
#################################
# 1. designate a data vector
#################################
# this has already been done; we'll use tset from before
tset <- seq(from = 0, to = 100, length.out = 20000) 


#################################
# 2. holding vector
#################################
N.over <- NaN*tset #empty box
N.over[1] <- N0 #initial conditions 


#################################
# 3. the for() loop
#################################
for(i in 2:length(tset)){
  dt <- tset[i] - tset[i-1]
  dNdt <- (r*N.over[i-1]*(1-N.over[i-1]/K)*(2-N.over[i-1]/K))*dt
  N.over[i] <- N.over[i-1] + dNdt
}
```

After checking the output of your `for()` loop. you can plot it.
```{r}
#############################################
# 1. plot the overcompensating population 
#############################################
plot(x = tset, y = N.over, 
     type = 'l', 
     las = 1, 
     lwd = 2, 
     xlab = 'Time', ylab = 'Population Size')

#############################################
# 2. plot the logistic to compare
#############################################
lines(x = tset, y = N.simu, lwd = 2, lty = 3)

#############################################
# 3. legend
#############################################
legend(x = max(tset)*.6, y = K*.5, 
       legend = c('Overcomp.','Logistic'), 
       lwd = 2, 
       lty = c(1,3))
```
Do the equilibria differ? What about the time to get to the equilibrium value? Why do you think this is the case?

## Think Pair Share 2: N_MSY, E_MSY, and Y_MSY

What are $N_{MSY}$, $E_{MSY}$, and $Y_{MSY}$ for this overcompensating population?  

First, determine the maximum yield using the `max()` function. (**Hint:** where would yield be highest, if you are looking at the plot of $\frac{dN}{dt}$ as a function of $N$?) Use variable assignment to name this `Y_MSY.over`.
```{r}
Y_MSY.over <- max(dNdt.over)
Y_MSY.over

#taking max from overcompensating equation
```

Then, find the population size at which this maximum yield occurs.
```{r}
# annotate the for() loop
for(i in 1:length(Nset)){ #iterate over possible pop sizes 
  if(dNdt.over[i] == Y_MSY.over){ #when dNdt vector hits max (if equal to Y_MSY.over) 
    N_MSY.over <- Nset[i] #we will store it in N_MSY.over
  } #close the function
}

N_MSY.over
```

Lastly, calculate effort given your values for `Y_MSY.over` and `N_MSY.over`. Recall that $Y = qEN$. Name this value `E_MSY.over`.
```{r}

E_MSY.over <- Y_MSY.over/(q*N_MSY.over)
E_MSY.over

```

Now that you're done, check your results by making a graph of population change due to biology (in black) and economics (in blue) as a function of population size.  

As we did before, we'll create a new vector for `growth.over` to indicate population growth in an overcompensating population. It'll be the same as `dNdt.over`, just renamed so that we can keep things straight with the axes.
```{r}
growth.over <- dNdt.over
```


Fill in the axis blanks.
```{r}
###################################
# 1. biology
###################################
plot(x = Nset, y = growth.over, 
     type = 'l', 
     lwd = 2, 
     las = 1, 
     xlab = 'N', ylab = 'Change in Population', main = 'overcompensating')
# add a line at the x-axis
abline(h = 0)

###################################
# 2. economics
###################################
lines(x = Nset, y = q*E_MSY.over*Nset, #this is a straight line using q, previously derived effort and range of population 
      lwd = 2,
      col = 'royalblue2')

###################################
# 3. equilibria
###################################
# unstable
points(x = 0, y = 0, 
       pch = 21, cex = 1.5)
# stable
points(x = N_MSY.over, y = Y_MSY.over,
       pch = 21, cex = 1.5, 
       bg = 'black')

###################################
# 4. legend
###################################
legend(x = 80, y = Y_MSY.over, 
       legend = c('growth', 'harvest', 'unstable equil.', 'stable equil.'), 
       lwd = c(2, 2, NaN, NaN), 
       pch = c(NaN, NaN, 21, 21), 
       pt.cex = 1.5, 
       cex = 0.8,
       pt.bg = c('white', 'white', 'white', 'black'), 
       col = c('black', 'royalblue2', 'black', 'black'))
```

Use a simulation with a `for()` loop to make sure that your equilibrium point is accurate. Is it stable?
```{r}
###################################################
# 1. create a set of time points to iterate over
###################################################
# use tset

#############################################################
# 2. create a storage vector and fill in initial conditions
#############################################################
N.simu.over <- NaN*tset
N.simu.over[1] <- N0 #indexing


#############################################################
# 3. for() loop: calculate population size change over time
#############################################################
# annotate each line of code
for(i in 2:length(tset)){
  dt <- tset[i] - tset[i - 1] #
  dNdt.over <- (r*N.simu.over[i-1]*(1-N.simu.over[i-1]/K)*(2-N.simu.over[i-1]/K)-q*E_MSY.over*N.simu.over[i-1])*dt #
  N.simu.over[i] <- N.simu.over[i-1] + dNdt.over #
}
```


After checking the output of your `for()` loop, plot it.
```{r}
plot(x = tset, y = N.simu.over, 
     type = 'l', 
     lwd = 2, 
     xlab = 'Time', ylab = 'Population Size')
```

Compare the outputs of each method. Are they similar?
```{r}
#compare

#pull from above
N.simu.over[length(tset)]

#compare
N_MSY.over

```


# 6. Harvesting a stock with depensating recruitment ('Allee Effects')

In some populations, we observe something called 'depensation,' which is the opposite of overcompensation. In such stocks, at low population sizes the population growth rate is slowed. Such phenomena were first described by Warder Allee; hence they are sometimes called 'Allee Effects.' Allee effects may be strong or weak: If an Allee effect is strong, then a population has a threshold size below which it will go extinct. (A good example of this would be for sexual reproducers: unless there are individuals of both sexes, the population will die out.) Weak Allee effects occur when growth rates are still positive, but they are lower than would be expected in a logistically growing population.  

We can represent this mathematically by modifying the logistic equation:

$\frac{dN}{dt} = rN(1-\frac{N}{K})(\frac{N}{A})$

The third term reduces the growth rate whenever $N < A$, but increases growth rate when $N > A$. A is the 'Allee' parameter, the threshold population size at which the population's growth rate starts to be reduced because the population is too small.  

Let's set $A = \frac{K}{2}$.
```{r}
A <- K/2 #allee modifier
```

As above, it's useful to plot $\frac{dN}{dt}$ as a function of population size and compare between logistic and depensating populations.  

First, we'll calculate $\frac{dN}{dt}$ for the depensating population.
```{r}
dNdt.dep <- r*Nset*(1-Nset/K)*(Nset/A) #multiplying Allee parameter
```

Then, we can plot it.

```{r}
######################################
# 1. plot dN/dt as a function of N
######################################
plot(x = Nset, y = dNdt.dep, 
     type = 'l', 
     lwd = 2, 
     las = 1, 
     xlab = 'N', ylab ='dN/dt')
abline(h = 0)

################################################
# 2. plot our logistic function for comparison
################################################
lines(x = Nset, y = dNdt.log, 
      lwd = 2, 
      lty = 3)
legend(x = 0, y= -1, 
       lwd = 2, 
       legend = c('Depensating','Logistic'), 
       lty = c(1, 3))
```

We can also compare how two populations, which start at the same population size, would grow differently over time depending on which function applied to them. As above, we can do this using a `for()` loop.
```{r}
###############################
# 1. designate a data vector
###############################
# this has already been done; we'll use tset

###############################
# 2. create a holding vector
###############################
N.dep <- NaN*tset
# set initial conditions
N.dep[1] <- N0

###############################
#. 3. the for() loop
###############################
for(i in 2:length(tset)){
  dt <- tset[i]-tset[i-1]
  dNdt <- (r*N.dep[i-1]*(1-N.dep[i-1]/K)*(N.dep[i-1]/A))*dt
  N.dep[i] <- N.dep[i-1]+dNdt
}
```

After checking the output of the `for()` loop, plot it.
```{r}
###################################################################
# 1. plot N of the depensating population as a function of time
###################################################################
plot(x = tset, y = N.dep, 
     type = 'l', 
     las = 1, 
     lwd = 2, 
     ylim = c(0, 120),
     xlab = 'Time', ylab = 'Population Size')

##################################################
# 2. plot the logistic function for comparison
##################################################
lines(x = tset, y = N.simu, 
      lwd = 2, 
      lty = 3)

######################
# 3. add a legend
######################
legend(x = max(tset)*.6, y = K*.5, 
       lwd = 2, 
       legend = c('Depensating', 'Logistic'), 
       lty = c(1, 3))
```
Do the equilibria differ? What about the time to get to the equilibrium value? Why do you think this is the case?

## Think Pair Share 3: N_MSY, E_MSY, and Y_MSY

What are $N_{MSY}$, $E_{MSY}$, and $Y_{MSY}$ for this depensating population?

First, determine the maximum yield using the `max()` function. Assign this variable to an object called `Y_MSY.dep`.
```{r}
Y_MSY.dep <- max(dNdt.dep)
Y_MSY.dep

```

Then, find the population size at which this maximum yield occurs using a `for()` loop.
```{r}
# annotate the for() loop
for(i in 1:length(Nset)){ #iterate over possible pop sizes 
  if(dNdt.dep[i] == Y_MSY.dep){ #when dNdt vector hits max (if equal to Y_MSY.dep) 
    N_MSY.dep <- Nset[i] #we will store it in N_MSY.over
  } #close the function
}

N_MSY.dep
```

Lastly, calculate effort given your values for `Y_MSY.dep` and `N_MSY.dep`. Recall that $Y = qEN$. Name this `E_MSY.dep`.
```{r}
N_MSY.dep
Y_MSY.dep

E_MSY.dep <- Y_MSY.dep/(q*N_MSY.dep)
E_MSY.dep
```

Again, we're going to create a new vector called `growth.dep` that will be the same as `dNdt.dep`.
```{r}
growth.dep <- dNdt.dep
```


Now that you're done, check your results by making a graph of population change due to biology (in black) and economics (in blue) as a function of population size.
```{r}
#################################
# 1. biology
#################################
plot(x = Nset, y = growth.dep, 
     type = 'l',
     lwd = 2, 
     las = 1, 
     xlab = 'N', ylab = 'Change in Population', main = 'depensating')
abline(h = 0)

#################################
# 2. economics
#################################
lines(x = Nset, y = q*E_MSY.dep*Nset, 
      lwd = 2,
      col = 'royalblue2')

#################################
# 3. stable equilibria
#################################
points(x = 0, y = 0, 
       pch = 21, 
       cex = 1.5, 
       bg = 'black')
points(x = N_MSY.dep, y = Y_MSY.dep, 
       pch = 21, 
       cex = 1.5,
       bg= 'black')

#################################
# 4. legend
#################################
legend(x = 0, y = -1, 
       pt.cex = 1.5, 
       legend = c('growth', 'harvest', 'unstable equil.', 'stable equil.'), 
       lwd = c(2, 2, NaN, NaN), 
       pch = c(NaN, NaN, 21, 21), 
       pt.bg = c('white', 'white', 'white', 'black'), 
       col = c('black', 'royalblue2', 'black', 'black'))
```

## a. Unstable equilibrium

You'll notice we don't have our unstable equilibrium labeled. How can we calculate the solution for the unstable equilibrium?
```{r}
N_star_unstable <- ((-r/A) + (sqrt((r^2/A^2) - ((4*r*q*E_MSY.dep)/(K*A)))) ) / ((-2*r) / (K*A))

Y.unstable.dep <- q * E_MSY.dep * N_star_unstable
```

Then, we can plot it.
```{r}
############################
# 1. biology
############################
plot(x = Nset, y = growth.dep, 
     type = 'l',
     lwd = 2, 
     las = 1,
     xlab = 'N', ylab = 'Change in Population', main = 'depensating')
abline(h = 0)

############################
# 2. economics
############################
lines(x = Nset, y = q*E_MSY.dep*Nset, 
      lwd = 2, 
      col = 'royalblue2')

############################
# 3. equilibria
############################
# stable
points(x = 0, y = 0, 
       pch = 21, 
       cex = 1.5, 
       bg = 'black')
points(x = N_MSY.dep, y = Y_MSY.dep, 
       pch = 21, 
       cex = 1.5, 
       bg = 'black')
# unstable
points(x = N_star_unstable, y = Y.unstable.dep, 
       pch = 21, cex = 1.5,
       bg = 'white')

############################
# 4. legend
############################
legend(x = 0, y = -1, 
       legend = c('growth', 'harvest', 'unstable equil.', 'stable equil.'), 
       lwd = c(2, 2, NaN, NaN), 
       pch = c(NaN, NaN, 21, 21), 
       pt.cex = 1.5, 
       pt.bg = c('white', 'white', 'white', 'black'), 
       col = c('black', 'royalblue2', 'black', 'black'))

# What's different about this graph? Hint: Look at the intersections between the blue and black lines.
```

Use a simulation to make sure that your equilibrium point is accurate. Is it stable? What if you start at N0 = K? N0 = 2? Hint: Make sure your simulation times are sufficiently long. In your timeseries plots, you should see the solution stabilize (i.e., turn into a horizontal line by the end of the timeseries)
```{r}
#################################
# 1. data to iterate over
#################################
# use tset again



#################################
# 2. holding vector
#################################
# create a bunch of different starting population sizes
N.simu.dep <- NaN*tset
N0.K <- K
N0.2 <- 2
N0.unstable <- N_star_unstable
N0.up <- N_star_unstable + 0.1
N0.down <- N_star_unstable - 0.1

# fill in initial conditions
N.simu.dep[1] <- N0.up # try the different N0 values defined above here



#################################
# 3. the for() loop
#################################
for(i in 2:length(tset)) {
  dt <- tset[i] - tset[i - 1] # calculate change in time
  dNdt.depen <- (r*N.simu.dep[i-1]*(1-N.simu.dep[i-1]/K)*(N.simu.dep[i-1]/A)-q*E_MSY.dep*N.simu.dep[i-1])*dt # logistic with N/A addition for depensating also with harvest
  N.simu.dep[i] <- N.simu.dep[i-1] + dNdt.depen
}
```

After checking the output of the `for()` loop, plot it.
```{r}
plot(x = tset, y = N.simu.dep, 
     type = "l", 
     lwd = 2, 
     xlab = "Time", ylab = "Population Size")
```

## b. Tipping points

Your results should suggest that this population has a 'tipping point': If the population is above the threshold, it will grow to $N^*$, but if the population is below the threshold, it will crash to zero. In ecology, we refer to systems like this as having "alternative stable states." Estimate the value of this tipping point. Hint: Pay attention to the extra intersection between the blue and black lines in the change in population graph. Make a timeseries plot (N vs. time) for multiple simulated populations, showing the system's dependence on initial conditions (N0).
```{r}
##########################################
# 1. designate a data vector (use tset)
##########################################
tset <- seq(from = 0, to = 100, length.out = 20000) # create a sequence of numbers from 0 to 100 that is 20000 values long



############################################
# 2. holding vector and initial conditions
############################################
#initial conditions
N0.low <- 33
N0.high <- 34

#holding vectors
N.simu.dep <- NaN*tset 
N.simu.dep.low <- NaN*tset
N.simu.dep.high <- NaN*tset
N.simu.dep.100 <- NaN*tset

#initial conditions
N.simu.dep[1] <- N0
N.simu.dep.low[1] <- N0.low
N.simu.dep.high[1] <- N0.high
N.simu.dep.100[1] <- N0.100

##########################################
# 3. the for() loop
##########################################
for(i in 2:length(tset)){
  deltat <- tset[i]-tset[i-1]
  deltaN <- (r*N.simu.dep[i-1]*(1-N.simu.dep[i-1]/K)*(N.simu.dep[i-1]/A)-q*E_MSY.dep*N.simu.dep[i-1])*deltat #different sets of N where we set our different initial conditions
  N.simu.dep[i] <- N.simu.dep[i-1]+deltaN
  
  deltaN <- (r*N.simu.dep.low[i-1]*(1-N.simu.dep.low[i-1]/K)*(N.simu.dep.low[i-1]/A)-q*E_MSY.dep*N.simu.dep.low[i-1])*deltat
  N.simu.dep.low[i] <- N.simu.dep.low[i-1]+deltaN
  
  deltaN <- (r*N.simu.dep.high[i-1]*(1-N.simu.dep.high[i-1]/K)*(N.simu.dep.high[i-1]/A)-q*E_MSY.dep*N.simu.dep.high[i-1])*deltat
  N.simu.dep.high[i] <- N.simu.dep.high[i-1]+deltaN
  
  deltaN <- (r*N.simu.dep.100[i-1]*(1-N.simu.dep.100[i-1]/K)*(N.simu.dep.100[i-1]/A)-q*E_MSY.dep*N.simu.dep.100[i-1])*deltat
  N.simu.dep.100[i] <- N.simu.dep.100[i-1]+deltaN
}
```

After you check the output of your `for()` loop, plot it.
```{r}
###################################
# 1. plot N as a function of time
###################################
plot(tset, N.simu.dep, #plotting timeseries
     type = 'l', 
     ylim = c(0, K), 
     las = 1, 
     lwd = 2, 
     xlab = 'Time', ylab = 'Population Size', main = 'tipping points')

#################################################
# 2. add lines for different initial conditions
#################################################
lines(tset, N.simu.dep.low, 
      col = 'paleturquoise3', 
      lwd = 2)
lines(tset, N.simu.dep.high, 
      col = 'peachpuff3', 
      lwd = 2)
lines(tset, N.simu.dep.100, 
      col = 'coral2', 
      lwd = 2)

###################################
# 3. legend
###################################
legend(x = max(tset)*.6, y = K, 
       lwd = 2,
       legend = c('N0=2', 'N0=33', 'N0=34', 'N0=100'), 
       col = c('black', 'paleturquoise3', 'peachpuff3', 'coral2'), 
       horiz = FALSE)
```

# 7. Homework

55 points total

We'll set up our parameters here, to make sure we're on the same page.
```{r}
r <- 0.5
K <- 100
q <- 0.1
A <- K/2 
N0 <- 2

#added E to be at max sustainable yeild
E <- 2.5 #calculated E_MSY (calculation below)
```

## 1. Logistically growing stocks
### i. Show your plot for population change vs. N (black line = biology, blue line = harvest) for a stock that grows logistically and is being managed to give its maximum sustainable yield.
**Remember: label your axes, and show legends!  **

```{r}
Nset <- seq(from = 0, to = K*1.1, length.out = 200) #make holding vector

dNdt.log <- r * Nset * (1-Nset/K) #vector multiplication (est growth rate times N times 1/k) - does this for every value of N since its a full vector

#calculating N* and Y at N*
Nstar <- K*(1-q*E/r)  #N* equation
Nstar

Ystar <- q*E*Nstar #what is our yeild at equilirbium ? 
Ystar


################################################
# 1. plot population growth as a function of N
################################################
plot(x = Nset, y = dNdt.log, #setting x as vector of possible pop sizes (Nset) and y as equation for log growth set above
     type = 'l', #line type
     las = 1, 
     lwd = 2, #line width
     xlab = 'N', ylab = 'Population Change') #axis labels

# add a line at the x-axis
abline(h = 0, lwd = 1)

################################################
# 2. plot the economics of harvest
################################################
lines(x = Nset, y = q*E*Nset, #linear line
      col = 'royalblue2', #color of the line
      lwd = 2) #tickness of line

################################################
# 3. add equilibria
################################################
# unstable
points(x = 0, y = 0, #unstable at origin beacuse N = 0 and Y = 0
       pch = 21, cex = 1.5) #point type
# stable
points(y = Ystar, x = Nstar, #stable at Ystar = Nstar 
       pch = 21, cex = 1.5, #point type 
       bg = 'black') #point color in

################################################
# 4. add a legend
################################################
legend(x = 0, y = -0.5, #position of axis
       legend = c('growth', 'harvest', 'unstable equil.', 'stable equil.'), #name of legend in a vactor
       lwd = c(2, 2, NaN, NaN), #line type
       pch = c(NaN, NaN, 21, 21), #shape size
       pt.cex = 1.5, #shape type
       pt.bg = c('white', 'white', 'white', 'black'), #shape fill
       col = c('black', 'royalblue2', 'black', 'black'), #outline color
       ncol = 2) #divide them into two columns
```


 /1 point for logistic growth line  
 /1 point for harvest line at MSY  
 /1 point for stable/unstable equilibria  
 /1 point for legend  
 /1 axes (popn change vs. N)  
 = /5 points total  
 

### ii. What are N_MSY, E_MSY, and Y_MSY for this stock? Print the values.  

```{r}
#doing it the algabraic way 
N_MSY <- K/2 #max pop
E_MSY <- r/q/2 #max effort 
Y_MSY <- r*K/4 #max yeild

#print values
N_MSY 
E_MSY 
Y_MSY 
```


 /1 for N_MSY  
 /1 for E_MSY  
 /1 for Y_MSY  
 = /3 points total  

## 2. Overcompensating stocks  
### i. Show your plot for population change vs. N for a stock that exhibits overcompensation being harvested at MSY.   

```{r}
dNdt.over <- r*Nset*(1-Nset/K)*(2-Nset/K) #equation for overcompensating population

#calc the values for E_MSY.over; N_MSY.over; Y_MSY.over
Y_MSY.over <- max(dNdt.over) #taking max from overcompensating equation
Y_MSY.over



#find the population size at which this maximum yield occurs using for() loop

for(i in 1:length(Nset)){ #iterate over possible pop sizes 
  if(dNdt.over[i] == Y_MSY.over){ #when dNdt vector hits max (if equal to Y_MSY.over) 
    N_MSY.over <- Nset[i] #we will store it in N_MSY.over
  } #close the function
}

N_MSY.over

E_MSY.over <- Y_MSY.over/(q*N_MSY.over)
E_MSY.over

###################################
# 1. biology
###################################
plot(x = Nset, y = dNdt.over, #x axis set as population; y as derivation equation from above
     type = 'l', #line type
     lwd = 2, #line width
     las = 1, #axis orientation
     xlab = 'N', ylab = 'Change in Population', main = 'overcompensating growth') #axis labels (i added title beacuse i was getting lost in the plots)
# add a line at the x-axis
abline(h = 0) #put a line at x = 0 

###################################
# 2. economics
###################################
lines(x = Nset, y = q*E_MSY.over*Nset, #this is a straight line using q, previously derived effort and range of population 
      lwd = 2, #line width
      col = 'royalblue2') #line color

###################################
# 3. equilibria
###################################
# unstable
points(x = 0, y = 0, #equilibrium at origin beacuse N = Y = 0
       pch = 21, cex = 1.5) #shape type
# stable
points(x = N_MSY.over, y = Y_MSY.over, #equilibrium at Nmax = Ymax
       pch = 21, cex = 1.5, #shape type
       bg = 'black') #color

###################################
# 4. legend
###################################
legend(x = 80, y = Y_MSY.over, #position of legend
       legend = c('growth', 'harvest', 'unstable equil.', 'stable equil.'), #names for legend
       lwd = c(2, 2, NaN, NaN), #line types
       pch = c(NaN, NaN, 21, 21), #shape types
       pt.cex = 1.5, #shape size
       cex = 0.8, #shape type
       pt.bg = c('white', 'white', 'white', 'black'), #point colors
       col = c('black', 'royalblue2', 'black', 'black')) #line colors
```
    
 /1 point for overcompensating stock line  
 /1 point for harvest line at MSY  
 /1 point for stable/unstable equilibria  
 /1 point for legend  
 /1 axes (popn change vs. N)  
 = /5 points total  

### ii. What are N_MSY, E_MSY, and Y_MSY for this stock? Print the values. 

```{r}
#printing here, calculations above!
N_MSY.over  
E_MSY.over  
Y_MSY.over

```
  
 /1 for N_MSY.over  
 /1 for E_MSY.over  
 /1 for Y_MSY.over  
 = /3 points total  

 
## 3. Depensating stocks
### i. Show your plot for population change vs. N at MSY  
Set Allee modifier as A
```{r}
A <- K/2 #allee modifier
```

calculate $\frac{dN}{dt}$ for the depensating population.
```{r}
dNdt.dep <- r*Nset*(1-Nset/K)*(Nset/A) #multiplying Allee parameter by log growth to get decompensating growth
```

Setting variables for max yeild
```{r}
Y_MSY.dep <- max(dNdt.dep) #set as max of the depensating equation
Y_MSY.dep #print the value

```

Find the population size at which this maximum yield occurs using a `for()` loop.
```{r}
# annotate the for() loop
for(i in 1:length(Nset)){ #iterate over possible pop sizes 
  if(dNdt.dep[i] == Y_MSY.dep){ #when dNdt vector hits max (if equal to Y_MSY.over) 
    N_MSY.dep <- Nset[i] #we will store it in N_MSY.over
  } #close the function
}

N_MSY.dep #print it out
```

Max effort calculation
```{r}
E_MSY.dep <- Y_MSY.dep/(q*N_MSY.dep) #calculate E_MSY.dep using equation for yeild
E_MSY.dep #print this
```

Add point with unstable equilibrium so it will plot 
```{r}
N_star_unstable <- ((-r/A) + (sqrt((r^2/A^2) - ((4*r*q*E_MSY.dep)/(K*A)))) ) / ((-2*r) / (K*A)) #equation for unstable equillibrium given in lab

Y.unstable.dep <- q * E_MSY.dep * N_star_unstable #setting max Yeild for the point at unstable equilibrium 
```

plot! 
```{r}
############################
# 1. biology
############################
plot(x = Nset, y = dNdt.dep, #set x as values for N; y as derivative with Allee modifier
     type = 'l', #line type
     lwd = 2, #thickness of line
     las = 1,
     xlab = 'N', ylab = 'Change in Population', main = 'depensating') #label axes and title
abline(h = 0) #put line at x = 0 

############################
# 2. economics
############################
lines(x = Nset, y = q*E_MSY.dep*Nset, #set line at values of 
      lwd = 2, #line thickness
      col = 'royalblue2') #line color

############################
# 3. equilibria
############################
# stable
points(x = 0, y = 0, #point at origin is stable (where N = 0, Y = 0)
       pch = 21,  #point type / size
       cex = 1.5,  #point type / size
       bg = 'black')#point coloring
points(x = N_MSY.dep, y = Y_MSY.dep, #setting stable point where N = Y (lines intersect)
       pch = 21,  #point type / size
       cex = 1.5,  #point type / size
       bg = 'black')#point coloring
# unstable
points(x = N_star_unstable, y = Y.unstable.dep, #setting unstable points where lines intersect using unstable equation above
       pch = 21, cex = 1.5, #point type / size
       bg = 'white') #point coloring

############################
# 4. legend
############################
legend(x = 0, y = -1, #position on graph of legend
       legend = c('growth', 'harvest', 'unstable equil.', 'stable equil.'), #name lagened (in a vactor)
       lwd = c(2, 2, NaN, NaN), #assign each vector to a line type
       pch = c(NaN, NaN, 21, 21), #assign each vector to a shape size
       pt.cex = 1.5, #shape type
       pt.bg = c('white', 'white', 'white', 'black'), #color of fill
       col = c('black', 'royalblue2', 'black', 'black')) #color of outilne

```

 /1 point for depensating stock line  
 /1 point for harvest line at MSY  
 /1 point for stable equilibrium  
 /1 point for unstable equilibrium  
 /1 point for legend  
 /1 axes (popn change vs. N)  
 = /6 points total  
 
 
### ii. What are N_MSY, E_MSY, and Y_MSY for this stock? Print the values.  

```{r}
#calculated above

N_MSY.dep
E_MSY.dep
Y_MSY.dep
```

 /1 for N_MSY.dep  
 /1 for E_MSY.dep  
 /1 for Y_MSY.dep  
 = /3 points total  

 
### iii. At what population size does this model exhibit a 'tipping point'? What are the two alternative states it might exhibit?  

Since the middle equilibrium is unstable (where N = ~33), this represents the population size at which it will go from one stable state to the other. The two alternative states are a crash to zero (and stable state existing at population of zero), or growth to N*. So in the fisheries example the alternative stable states represent a devastated population (1) or a population at equilibrium of carrying capacity (2). 

 /1 point for 'tipping point' population size  
 /1 point first alternative state  
 /1 point for second alternative state   
 = /3 points total 

 
### iv. Provide a graph of population trajectories (using different initial population sizes) that illustrates this tipping point. Hint: Your graph should have multiple population trajectories on it, and you will need a legend that indicates the N0 values corresponding to each.  

```{r}
##########################################
# 1. designate a data vector (use tset)
##########################################
tset <- seq(from = 0, to = 100, length.out = 20000) # create a sequence of numbers from 0 to 100 that is 20000 values long



############################################
# 2. holding vector and initial conditions
############################################
#initial conditions
N0.low <- 33
N0.high <- 34

#holding vectors
N.simu.dep <- NaN*tset 
N.simu.dep.low <- NaN*tset
N.simu.dep.high <- NaN*tset

#initial indexing for holding vectors
N.simu.dep[1] <- N0
N.simu.dep.low[1] <- N0.low
N.simu.dep.high[1] <- N0.high

##########################################
# 3. the for() loop
##########################################
for(i in 2:length(tset)){ #iterate over length of tset vector starting at i in 2
  deltaN <- (r*N.simu.dep.low[i-1]*(1-N.simu.dep.low[i-1]/K)*(N.simu.dep.low[i-1]/A)-q*E_MSY.dep*N.simu.dep.low[i-1])*deltat #inputting different sets of N where we set our different initial conditions so that the change in N for each time steps depends on depensating model for growth (this is why we input E_MSY.dep etc). We use these values since the depensating model is the one which exhibits tipping points
  N.simu.dep.low[i] <- N.simu.dep.low[i-1]+deltaN #each step in vector that is filled then depends on this delta equation from above
  
  deltaN <- (r*N.simu.dep.high[i-1]*(1-N.simu.dep.high[i-1]/K)*(N.simu.dep.high[i-1]/A)-q*E_MSY.dep*N.simu.dep.high[i-1])*deltat #putting in the other starting value for N we have given as initial condiiton
  N.simu.dep.high[i] <- N.simu.dep.high[i-1]+deltaN
  
}
```

After you check the output of your `for()` loop, plot it.
```{r}
###################################
# 1. plot N as a function of time
###################################
plot(tset, N.simu.dep, #plotting timeseries
     type = 'l', #line type
     ylim = c(0, K), #limits for y axis scale
     las = 1, #orientation of axis
     lwd = 2, #line type
     xlab = 'Time (t)', ylab = 'Population Size (N)', main = 'tipping points') #labeling axes and main plot

#################################################
# 2. add lines for different initial conditions
#################################################
lines(tset, N.simu.dep.low, #line showing initial condition with N0 as 33
      col = 'paleturquoise3', 
      lwd = 2)
lines(tset, N.simu.dep.high, #line showing initial condition with N0 as 34
      col = 'peachpuff3', 
      lwd = 2)

###################################
# 3. legend
###################################
legend(x = max(tset)*.6, y = K, #legend position 
       lwd = 2, #line type in legend
       legend = c('N0=33', 'N0=34'), #labels in legend
       col = c('paleturquoise3', 'peachpuff3'), #colors
       horiz = FALSE) 
```

 /1 point for population trajectory 1  
 /1 point for population trajectory 2  
 /1 point for legend  
 /1 point for axes (N vs t)  
 = /4 points total
 
### v. If you were a manager of this stock, what would you be worried about? How might you try to avoid that problem?  

I would be worried about the tipping point being so fragile. These initial populations only started one point apart but led to different alternative stable states - one with a population crash and the other with the population leveling out. If I were the manager of this population I would consider the outcome of different tipping points and given the severity, establish conservative catch limits to avoid tipping, along with consistent population estimates to make sure the population would avoid tipping. 

= /2 points total  

## 4. Subsidized stocks  
Consider a fishery whose population grows logistically and which is next to a marine reserve. No fishing is allowed in this marine reserve, so it contains a large, healthy population of fish. Some of this population spills over into the fished area at a rate of 'M' fish per unit of time.  
We can represent this mathematically as:  
$\frac{dN}{dt} = r*N*(1-\frac{N}{K}) - q*E*N + M$  
Let's continue to use the parameters $r = 0.5$ and $K = 100$. Let's further set $M = 10$.  

### i. Plot the 'biology' and the 'economics' as a function of population size. That is, make a plot with N on the x-axis and two lines, one representing the subsidized logistic growth (r*N*(1-N/K) + M), and one representing harvest (q*E*N). For the economics, choose E = E_MSY from your logistic analysis in the first part of this lab.  

```{r}
#set parameters
r = 0.5
K = 100
M = 10


#set the equation as given above
dNdt.subs <- r*Nset*(1-(Nset/K)) + M

#set up the plot
plot(x = Nset, y = dNdt.subs, #setting x as vector of possible pop sizes (Nset) and y as equation for log growth set above
     type = 'l', #line type
     las = 1, 
     lwd = 2, #line width
     ylim = c(-5, 25), #my fig was looking weird so i set y axis limits
     xlab = 'N', ylab = 'Population Change', main = 'subsidized') #axis labels

# add a line at the x-axis and y-axis
abline(h = 0, lwd = 1)
abline(v = 0, lwd = 1)

################################################
# 2. plot the economics of harvest
################################################
lines(x = Nset, y = q*E_MSY*Nset, #linear line usign E_MSY as suggested above
      col = 'royalblue2', #color of the line
      lwd = 2) #tickness of line

################################################
# 4. add a legend
################################################
legend(x = 0, y = -0.5, #position of axis
       legend = c('growth', 'harvest'), #name of legend in a vactor
       lwd = c(2, 2), #line type 
       col = c('black', 'royalblue2'), #outline color
       ncol = 2) #divide them into two columns

```

 /1 point for subsidized stock line  
 /1 point for harvest line   
 /1 point legend  
 /1 point for axes (popn change vs. N)  
 = /6 points total  
 
### ii. Does this effort level still yield the maximum sustainable yield?  

No, it yields below the max sustainable yield. 

 = /1 point total   
 
### iii. If not, adjust effort and report your new E_MSY, N_MSY, and Y_MSY.  

```{r}

#set parameters
r = 0.5
K = 100
M = 10

Y_MSY.sub <- max(dNdt.subs) #what is our max yeild based on the equation 
Y_MSY.sub

#solve for E at MSY - first have to solve for N at MSY
# annotate the for() loop
for(i in 1:length(Nset)){ #iterate over possible pop sizes 
  if(dNdt.subs[i] == Y_MSY.sub){ #when dNdt vector hits max (if equal to Y_MSY.sub) 
    N_MSY.sub <- Nset[i] #we will store it in N_MSY.sub
  } #close the function
}

N_MSY.sub

E_MSY.sub <- Y_MSY.sub/(q*N_MSY.sub)
E_MSY.sub
```

 /1 point for N_MSY.sub  
 /1 point for E_MSY.sub  
 /1 point for Y_MSY.sub  
 = /3 points  

### iv. Make a new version of your graph from part (i), but using your new E_MSY.  

```{r}
#set up the plot
plot(x = Nset, y = dNdt.subs, #setting x as vector of possible pop sizes (Nset) and y as equation for log growth set above
     type = 'l', #line type
     las = 1, #axis orientation
     ylim = c(-5, 25), #setting y axis bounds because my graph was getting wonky
     lwd = 2, #line width
     xlab = 'N', ylab = 'Population Change', main = 'subsidized, increased effort') #axis labels

# add a line at the x-axis and y-axis
abline(h = 0, lwd = 1)
abline(v = 0, lwd = 1)

################################################
# 2. plot the economics of harvest (changing the value for E)
################################################
lines(x = Nset, y = q*E_MSY.sub*Nset, #linear line using E_MSY.sub
      col = 'royalblue2', #color of the line
      lwd = 2,
      lty = 3) #tickness of line

################################################
# 4. add a legend
################################################
legend(x = 0, y = -0.5, #position of axis
       legend = c('growth', 'harvest'), #name of legend in a vactor
       lwd = c(2, 2), #line type 
       col = c('black', 'royalblue2'), #outline color
       ncol = 2,
       lty = c(1, 3)) #divide them into two columns
```
  
 /1 point for subsidized stock line  
 /1 point for harvest line with new E_MSY from the subsidized stock analysis  
 /1 point for stable equilibrium  
 /1 point legend  
 /1 point for axes (popn change vs. N)  
 = /5 points total  

  
### v. Explain how having the nearby reserve affected the fishery you are managing.  

The parabola for growth of the population peaked at a higher point when there was a nearby reserve. The influx of population from that source bolstered the population and also resulted in a higher value for N* at equilibrium. 

 = /2 points total   


## 5. Comparison across stocks: Compare N_MSY and E_MSY for the four stocks you've studied in this lab. Explain, biologically, why any differences exist.  

```{r}
N_MSY
N_MSY.dep
N_MSY.over
N_MSY.sub

E_MSY
E_MSY.dep
E_MSY.over
E_MSY.sub
```

Across stocks, the N_MSY changed a lot. The stock with the lowest MSY was the stock depensating  growth. This makes sense because these populations are undergoing depressed growth rates, resulting in smaller population sizes. On the other hand, overcompensating populations which have high growth or fecund females etc. exhibit the high N_MSY values, showing the impact that these natural differences in the population result in differences in their max population sizes. Subsidizing led to slightly lower N_MSY than the logistically growing population which was interesting since I might have expected a subsidized population to have a higher max population size but possibly this is just a more accurate way to measure the population. The N_MSY.sub when rounded is the same as the logistic growth model.  

Across logistic, overcompensating, depensating and subsidized stocks, the E_MSY varied as well. The lowest effort was found in the overcompensating stock. This again makes intrinsic sense as the population with a larger max value would require less effort to yield max values. Interestingly, the E_MAY.sub was only slightly lower than the overcompensating stock, but yeilded a much higher N_MSY, suggesting the subsidized stock was worth the effort. 

 /2 points for N_MSY comparison across logistic, overcompensating, depensating and subsidized stocks  
 /2 points for E_MSY comparison across logistic, overcompensating, depensating and subsidized stocks  
 = /4 points total  

