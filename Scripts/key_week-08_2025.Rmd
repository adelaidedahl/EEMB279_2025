---
title: "Lab 7 - Mutualism and co-invasion"
date: "24 February 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Announcements -- 

Next lab (3/7): final project work and help with coding & analysis

Week 10 lab (3/14): final project presentations

# Lab overview
This week, we have been talking about mutualistic interactions between species. These are +/+ interactions, in which each species enhances the other's growth.  

 Of course, all species interactions exist on a spectrum: Interactions may vary in their degree of benefit, and, in some cases, depending on environmental context, may become non-beneficial or even harmful (e.g., parasitism).  

 Neuhauser & Fargione (2004) developed a model that can account for this gradient from mutualism (+/+) to parasitism (+/-).  

 They model a host, H, and a 'partner or parasite,' P, who affect one another's growth in the following ways: (1) P enhances H's carrying capacity, with a per-capita 'gain' level of gamma, (2) H supports P's growth by increasing P's birth rate at a per-capita rate b, and (3) P may also negatively impact H by 'exploitation' at a per-capita rate a.  

 The full set of equations is:
$$
\begin{align}
\frac{dH}{dt} &= r H ( 1 - \frac{H}{K+\gamma P} ) - a H P \\ 
\newline
\frac{dP}{dt} &= b H P - m P (1+eP) \\ 
\end{align}
$$
 
**Note:** we've made a change to the NH04 model's notation, replacing the 'death rate' $d$ of $P$ with the mortality constant $m$. This change was just made to improve clarity of notation (i.e., to make it obvious that $mP$ was not a derivative).  

 In this lab, you will be exploring:  
	1. The effect of changing the direction and strength of species interactions (i.e. illustrating the gradient from mutualism to parasitism),  
	2. How to turn this into a spatial model of two interacting species spreading across a landscape,   
	3. How dispersal rates of each partner interact to change the speed of the "invasion wave," and  
	4. The implications for control of the spread of non-native species.  

# PART ONE: A gradient from mutualism to parasitism

## a. Getting to know the model
Let's begin by choosing some parameters, plotting the ZNGIs, checking their predictions by simulating the model's dynamics, and interpreting these predictions.

```{r}
r <- 1			# growth rate of H
K <- 20			# carrying capacity of H
gamma <- .5	# positive effect of P on H's carrying capacity
a <- .01		# exploitation of H by P
b <- 1			# growth rate of P
m <- 1			# density-independent mortality of P
e <- 1			# factor weighting density-dependent mortality of P
```

By setting $\frac{dH}{dt} = 0$ and $\frac{dP}{dt} = 0$, we can find four zero-net growth isoclines:  

From $\frac{dH}{dt}$:  
1. $H = 0$ or  
2. $H = \frac{1}{r*(K + \gamma*P)*(r-a*P)}$  

From $\frac{dP}{dt}$:  
3. $P = 0$ or  
4. $H = \frac{m}{b*(1+e*P)}$  

Let's plot these ZNGIs on a **phase plane**, with $H$ on the x-axis and $P$ on the y-axis.  
Note that even though $P$ is on the y-axis, it's easier to solve the ZNGIs - particularly the one from $\frac{dH}{dt}$ - for $H$. Therefore, we're making a vector of values for $P$ to plug in.

```{r}
# make a vector of values for P
Pset <- seq(from = 0, to = 100) # sequence from 0 to 100

# solve for dHdt and dPdt ZNGIs (and remember H =0 and P = 0 are also ZNGIs)
dHdt.ZNGI <- 1/r*(K+gamma*Pset)*(r-a*Pset) # values of H where dH/dt = 0 corresponding to each value of P in Pset; i.e., P = Pset and H = 1/r*(K+gamma*P)*(r-a*P)
dPdt.ZNGI <- m/b*(1+e*Pset) # values of H where dP/dt = 0 corresponding to each value of P in Pset; i.e., P = Pset and H = m/b*(1+e*P)
```

Check the output of those operations! What does `head(dHdt.ZNGI)` or `head(dPdt.ZNGI)` look like?
```{r}

head(dHdt.ZNGI)

head(dPdt.ZNGI)

```

After checking our outputs, we can plot.
```{r}
# assign colors for H and P that we'll use throughout lab
Hcol <- 'seagreen' # color for the host
Pcol <- 'royalblue' # color for the partner

# plot ZNGI for species H 
plot(x = dHdt.ZNGI, y = Pset, # x,y = combination of host size (x) and partner size (y) at which dH/dt = 0
     type = 'l', col = Hcol, lwd = 2, las = 1, # plot aesthetics (plot as a line, specify line color and thickness, make the y-axis tick mark labels horizontal)
     xlim = c(0, max(c(dHdt.ZNGI, dPdt.ZNGI)))/2,  # x-axis limits: from 0 to half of the max value on the y-axis
     xlab = 'H', ylab = 'P') # axis labels (this is a phase plane so each axis is a state variable)

# plot ZNGI for species P 
lines(x = dPdt.ZNGI, y = Pset, # x, y = combination of host size (x) and partner size (y) at which dP/dt = 0
      lwd = 2, col = Pcol) # line thickness and color

# plot ZNGIs for H = 0 and P = 0
abline(v = 0, lwd = 2, col = Hcol) # dH/dt = 0 when H = 0 (vertical line at x = 0)
abline(h = 0, lwd = 2, col= Pcol) # dP/dt = 0 when P = 0 (horizontal line at y = 0)
```

### Think, Pair, Share 1

(1) How many equilibria do you see?  

three (everywhere the blue and green ZNGIs intersect)

(2) Make a prediction for the stability of each equilibrium point. (Hint: Think about the sign of dP/dt 'above' and 'below' the blue diagonal line, and dH/dt 'inside' and 'outside' of the green curve.)  

(0, 0) = unstable saddle
(K, 0) = stable when K < m/b; here K > m/b so would predict it is an unstable saddle
(H^, P^) = stable

## b. Checking predictions by performing a simulation

Let's check your predictions by performing a simulation.
```{r}
# create a vector of timesteps to iterate over
tset <- seq(from = 0, to = 100, length.out = 5000) # sequence from 0 to 100 with a length of 5000

# create holding vectors and store initial conditions
H.simu1 <- NaN*tset; H.simu1[1] <- 1 # holding vector for the host; set initial host abundance to 1
P.simu1 <- NaN*tset; P.simu1[1] <- 1 # holding vector for the partner; set initial partner abundance to 1

# for each timestep
for(i in 2:length(tset)){
  # calculate change in time
	dt <- tset[i] - tset[i-1] # change in time is the difference between the current timepoint and the previous timepoint
	
	# store dummy variables
	H <- H.simu1[i-1] # call the host size at the previous timepoint H
	P <- P.simu1[i-1] # call the partner population size at the previous timepoint P
	
	# calculate change in population size of H and P
	dH <- ( r*H*(1-H/(K+gamma*P))-a*H*P )*dt # change in host population size over the interval dt
	dP <- ( b*H*P - m*P*(1+e*P) )*dt # change in partner population size over the interval dt
	
	# calculate total population size of H and P
	H.simu1[i] <- H + dH # host population size at ith timepoint = host population size at previous timepoint plus the change in the host population size over the interval dt
	P.simu1[i] <- P + dP	# partner population size at ith timepoint = partner population size at previous timepoint plus the change in the partner population size over the interval dt
}
```

Check the output of your `for()` loop! Remember: this is to make sure nothing weird is happening in the code for your loop. It is **not necessarily** a step that will tell you if your math is wrong!
```{r}

tail(H.simu1)

```

Now we can plot a timeseries:

```{r}
# plot H (H.simu1) as a function of time
plot(x = tset, y = H.simu1,  # x = time, y = host population size
     col = Hcol, type = 'l', lwd = 2, las = 1, # plot aesthetics
     xlab = 'Time', ylab = 'Population Size', # axis labels
     main = "Simulation 1: H and P", # plot title
     ylim = c(0, max(c(P.simu1, H.simu1)))) # y-axis limits: from 0 to the max value across P.simu1 and H.simu1

# plot P (P.simu1) as a function of time
lines(x = tset, y = P.simu1, # x = time, y = partner population size
      col = Pcol, lwd=2) # line color and thickness

# create a legend
legend(x = 60, y = K, # legend location
       legend = c('Host', 'Partner'), # labels for legend elements
       lwd = 2, # line thickness
       col = c(Hcol, Pcol)) # colors of legend elements
```

**Pro tip:** We can also check this by plotting it on the phase plane! We'll plot the trajectory of the community (i.e. the population sizes of H and P that we generated in the `for()` loop) on top of the  ZNGIs for H (in green) and P (in blue).  

**Note about trajectory:** When plotting the trajectory of the community, the population sizes of H are on the x-axis and P are on the y-axis. This keeps things consistent with the phase plane!  

**Note about equilibrium:** We'll also add a black dot at the end of the simulation indicating the equilibrium point. We are calling this a stable equilibrium because our timeseries simulation suggested that it was: The populations reached a stable size that didn't change over time. You should always be careful, when running simulations, to be certain that the system has 'equilibrated' before you make interpretations about its results!
```{r}
# assign color
Simucol <- 'salmon' # color to use for plotting our simulation trajectory (H vs. P at each timepoint)

# plot ZNGI for species H
plot(x = dHdt.ZNGI, y = Pset,  # x,y = combination of host size (x) and partner size (y) at which dH/dt = 0
     type = 'l', col = Hcol, lwd = 2, las=1, # plot aesthetics
     xlim=c(0, max(c(dHdt.ZNGI, dPdt.ZNGI)))/2, # x-axis limits
     xlab = 'H (Host)', ylab = 'P (Partner)', # axis labels
     main = expression("Phase plane: H"[0]*" and P"[0]*" = 1")) # plot title, using the expression() function to add subscripts. You can also use expression to type superscripts, mathematical symbols, greek letters, etc.

# plot ZNGI for species P
lines(x = dPdt.ZNGI, y = Pset, # x, y = combination of host size (x) and partner size (y) at which dP/dt = 0
      lwd = 2, col = Pcol) # line thickness and color

# plot ZNGIs at H = 0 and P = 0
abline(v = 0, lwd = 2, col = Hcol) # dH/dt = 0 when H = 0 (vertical line at x = 0)
abline(h = 0, lwd = 2, col= Pcol) # dP/dt = 0 when P = 0 (horizontal line at y = 0)

# plot simulated trajectory
lines(x = H.simu1, y = P.simu1, # x = host population sizes at each time point in the simulation, y = partner population sizes at each timepoint in the simulation
      col = Simucol, lwd = 2)	# line color and thickness

# add a filled equilibrium point.
points(x = H.simu1[length(tset)], y = P.simu1[length(tset)], # x = host population size at the end of the simulation, y = partner population size at the end of the simulation
       col = 'black', bg = 'black', pch = 21)	# point outline color, fill color, and shape (21 = circle)
```

### Think, Pair, Share 2
(1) Run a second simulation (be sure to save your results as new vectors, `H.simu2` and `P.simu2`), simulating the population dynamics when you start from an initial condition of $H = 100$ and $P = 100$.

```{r}
# create a vector of timesteps to iterate over
tset <- seq(from = 0, to = 100, length.out = 5000)

# create holding vectors and store initial conditions
H.simu2 <- NaN*tset; H.simu2[1] <- 100
P.simu2 <- NaN*tset; P.simu2[1] <- 100

# for each timestep
for(i in 2:length(tset)){
  # calculate change in time
	dt <- tset[i] - tset[i-1]
	
	# store placeholder variables
	H <- H.simu2[i-1]
	P <- P.simu2[i-1]
	
	# calculate change in population size of H and P
	dH <- ( r*H*(1-H/(K+gamma*P))-a*H*P )*dt
	dP <- ( b*H*P - m*P*(1+e*P) )*dt
	
	# calculate total population size of H and P
	H.simu2[i] <- H + dH
	P.simu2[i] <- P + dP	
}
```

(2) Plot a timeseries to check that your simulation has reached an equilibrium.

```{r}
# plot H (H.simu2) as a function of time
plot(x = tset, y = H.simu2, 
     col = Hcol, type = 'l', lwd = 2, las = 1,
     xlab = 'Time', ylab = 'Population Size', 
     main = expression("Simulation 2: H"[0]*" and P"[0]*" = 100"))

# plot P (P.simu2) as a function of time
lines(x = tset, y = P.simu2, 
      col = Pcol, lwd=2)

# create a legend
legend(x = 60, y = 80, 
       legend = c('Host', 'Partner'), 
       lwd = 2, 
       col = c(Hcol, Pcol))
```

(3) Add the results of your second simulation to the P vs. H phase plane. Have you reached the same equilibrium point? What does this suggest about its stability?

```{r}
# plot ZNGI for species H
plot(x = dHdt.ZNGI, y = Pset,  # x,y = combination of host size (x) and partner size (y) at which dH/dt = 0
     type = 'l', col = Hcol, lwd = 2, las=1, # plot aesthetics
     xlim=c(0, 100)/2, # x-axis limits
     xlab = 'H (Host)', ylab = 'P (Partner)', # axis labels
     main = expression("Phase plane: H"[0]*" and P"[0]*" = 100")) # plot title,

# plot ZNGI for species P
lines(x = dPdt.ZNGI, y = Pset, # x, y = combination of host size (x) and partner size (y) at which dP/dt = 0
      lwd = 2, col = Pcol) # line thickness and color

# plot ZNGIs at H = 0 and P = 0
abline(v = 0, lwd = 2, col = Hcol) # dH/dt = 0 when H = 0 (vertical line at x = 0)
abline(h = 0, lwd = 2, col= Pcol) # dP/dt = 0 when P = 0 (horizontal line at y = 0)

# plot simulated trajectory
lines(x = H.simu2, y = P.simu2, # x = host population sizes at each time point in the simulation, y = partner population sizes at each timepoint in the simulation
      col = Simucol, lwd = 2)		# line color and thickness

# add a filled equilibrium point.
points(x = H.simu2[length(tset)], y = P.simu2[length(tset)], # x = host population size at the end of the simulation, y = partner population size at the end of the simulation
       col = 'black', bg = 'black', pch = 21)	# point outline color, fill color, and shape (21 = circle)
```

## c.  Making a bifurcation diagram with respect to 'a'

The parameter $a$ is the exploitation rate of $H$ by $P$. Let's explore how changing $a$ alters the equilibrium population sizes of both $H$ and $P$.

### Think, Pair, Share 3
(1) Create a vector `aset` containing values for $a$ ranging from 0 to 0.1.  

**Hint:** The longer your `aset` vector, the longer it will take you to run the calculations to make your bifurcation diagram. It's often good to start out with a short vector (e.g., `length.out = 10`) to make sure things are working. You can always increase the length to 'smooth things out' later.)

```{r}
aset <- seq(from = 0, to = 0.1, length.out = 10) # 10 "a" values ranging from 0 to 0.1
```

(2) Make two bifurcation diagrams showing the equilibrium population sizes of $H$ and $P$ as a function of $a$.

```{r}
Hstar_a <- NaN*aset # holding vector for equilibrium host population size at each value of a
Pstar_a <- NaN*aset # holding vector for equilibrium partner population size at each value of a

for(j in 1:length(aset)){ # for each element j in 1 to length of aset
  
  # assign a value for a from aset
  a <- aset[j] # set a equal to the jth value of aset
  
  # create holding vectors and store initial conditions
  H.simu <- NaN*tset; H.simu[1] <- 100 
  P.simu <- NaN*tset; P.simu[1] <- 100
  
  # inner for loop: simulate the model with a = aset[j]
  # for each timestep
  for(i in 2:length(tset)){
    # calculate change in time
    dt <- tset[i] - tset[i-1]
    
    # store placeholder variables
    H <- H.simu[i-1]
    P <- P.simu[i-1]
    
    # calculate change in population size of H and P
    dH <- ( r*H*(1-H/(K+gamma*P))-a*H*P )*dt
    dP <- ( b*H*P - m*P*(1+e*P) )*dt
    
    # calculate total population size of H and P
    H.simu[i] <- H + dH
    P.simu[i] <- P + dP	
  } # end of inner for loop that simulates the population sizes over time
  
  # store the equilibrium host and partner population sizes (the population sizes at the end of the simulation) for this value of the parameter a
  Hstar_a[j] <- H.simu[length(H.simu)]
  Pstar_a[j] <- P.simu[length(P.simu)]
  
} # end of outer loop that iterates over all of the values of the parameter a in aset

# plot bifurcation diagram
plot(x = aset, y = Hstar_a, # x = the parameter a, y = the corresponding equilibrium host population sizes
     type = "l", las = 1, lwd = 2, col = Hcol, # plot aesthetics
     xlab = "Exploitation rate (a)", ylab = "H*", # axis labels
     main = "Bifurcation of H* with respect to a") # plot title

plot(x = aset, y = Pstar_a, # x = the parameter a, y = the corresponding equilibrium partner population sizes
     type = "l", las = 1, lwd = 2, col = Pcol, # plot aesthetics
     xlab = "Exploitation rate (a)", ylab = "P*", # axis labels
     main = "Bifurcation of P* with respect to a") # plot title
```

(3) Interpret your bifurcation diagram in words. What happens to each population as $a$ increases? How does the equilibrium population size of $H$ compare to its carrying capacity, $K$? Plot $H^*$ as a function of $a$.

```{r}

plot(x = aset, y = Hstar_a, 
     type = "l", las = 1, lwd = 2, col = Hcol,
     xlab = "Exploitation rate (a)", ylab = "H*",
     main = "Bifurcation of H* with respect to a")
abline(h = K, lty = 2, col = 'black') # add a horizontal line at y = K to see for which values of a the equilibrium host population size is above or below K

```

As the exploitation rate increases, the equilibrium population sizes of the host and partner both decrease. This is because a higher exploitation rate means the partner is removing more of the host population, and a lower host population means the growth of the partner population is lower, so both H and P decline. When exploitation rate is high enough (greater than ~0.02), the equilibrium host population size falls below it's carrying capacity, so we would consider the partner to be a parasite.


(4) Make two bifurcation diagrams showing the equilibrium population sizes of $H$ and $P$ as a function of $b$ to illustrate the effect of increasing the slope of the non-zero partner ZNGI (as we did in lecture). Interpret your bifurcation diagram in words.  

**Note:** Remember to 'reset' your parameters in this chunk (`a` is not at its default from the previous simulation).
```{r}
a <- .01 # reset the value of a to its default

# create a vector of values of b
bset <- seq(from = 1, to = 5, length.out = 100) # 100 values of b ranging from 1 to 5

Hstar_b <- NaN*bset # holding vector for equilibrium host population size at each value of b 
Pstar_b <- NaN*bset # holding vector for equilibrium partner population size at each value of b 

for(j in 1:length(bset)){ # for each element j in 1 to length of bset
  
  # assign the value for b from bset
  b <- bset[j] # set b equal to the jth value of bset
  
  # create holding vectors and store initial conditions
  H.simu <- NaN*tset; H.simu[1] <- 1
  P.simu <- NaN*tset; P.simu[1] <- 1
  
  # inner for loop: simulate the model with b = bset[j]
  # for each timestep
  for(i in 2:length(tset)){
    # calculate change in time
    dt <- tset[i] - tset[i-1]
    
    # store placeholder variables
    H <- H.simu[i-1]
    P <- P.simu[i-1]
    
    # calculate change in population size of H and P
    dH <- ( r*H*(1-H/(K+gamma*P))-a*H*P )*dt
    dP <- ( b*H*P - m*P*(1+e*P) )*dt
    
    # calculate total population size of H and P
    H.simu[i] <- H + dH
    P.simu[i] <- P + dP	
  } # end of inner for loop that simulates the population sizes over time
  
  # store the equilibrium host and partner population sizes (the population sizes at the end of the simulation) for this value of the parameter b
  Hstar_b[j] <- H.simu[length(H.simu)]
  Pstar_b[j] <- P.simu[length(P.simu)]
  
}  # end of outer loop that iterates over all of the values of the parameter b in bset

# plot bifurcation diagram
plot(x = bset, y = Hstar_b, # x = the parameter b, y = the corresponding equilibrium host population sizes
     type = "l", las = 1, lwd = 2, col = Hcol, # plot aesthetics
     xlab = "Growth rate of P (b)", ylab = "H*", # axis labels
     main = "Bifurcation of H* with respect to b") # plot title
abline(h = K, lty = 2, col = 'black') # add a horizontal line at y = K to see for which values of b the equilibrium host population size is above or below K

plot(x = bset, y = Pstar_b, # x = the parameter b, y = the corresponding equilibrium partner population sizes
     type = "l", las = 1, lwd = 2, col = Pcol, # plot aesthetics
     xlab = "Growth rate of P (b)", ylab = "P*", # axis labels
     main = "Bifurcation of P* with respect to b") # plot title

```

Interpretation: as the growth rate of the partner increases, the equilibrium host population size initially increases (because P is increasing it's carrying capacity), but then decreases because a larger partner population size means it is being exploited at a higher rate (so there is this tension between the benefit of the partner, i.e., the increased carrying capacity, and the costs of the partner, i.e., the exploitation). As the growth rate of the partner increases, the partner population size also increases, although if b is high enough the partner population size will eventually saturate and stop increasing (since the host population size is decreasing, and the partner requires the host to grow)

## d. Choosing values of 'a' that represent 'mutualist' and 'parasite' cases

For the rest of the lab, we'll be considering the case when P is either a **mutualistic partner** or a **parasite**. We'll use two values of $a$ - in the code as `a_mut` and `a_par` - to distinguish these cases:

```{r}
r <- 1			# growth rate of H
K <- 20			# carrying capacity of H
gamma <- .5		# positive effect of P on H's carrying capacity
a <- .01		# exploitation of H by P
b <- 1			# growth rate of P
m <- 1			# density-independent mortality of P
e <- 1			# factor weighting density-dependent mortality of P

a_mut <- 0 # value of a for which the partner is a mutualist
a_par <- 0.05 # value of a for which the partner is a parasite
```

Let's get to know the predictions of each of these cases by plotting the trajectories on a phase plane. We'll start with the mutualist case.  

First, we'll calculate our ZNGIs for H and P given that P is a mutualist.

```{r}
# calculate ZNGIs for H and P given that P is a mutualist
dHdt.ZNGI.mut <- 1/r*(K+gamma*Pset)*(r-a_mut*Pset) # H's non-zero ZNGI for case where partner is a mutualist
dPdt.ZNGI.mut <- m/b*(1+e*Pset) # P's non-zero ZNGI for case where partner is a mutualist
```

Then, we'll simulate using a `for()` loop.
```{r}
# create holding vectors and store initial conditions
H.simu.mut <- NaN*tset; H.simu.mut[1] <- 1 # holding vector and initial conditions for host
P.simu.mut <- NaN*tset; P.simu.mut[1] <- 1 # holding vector and initial conditions for partner

# for each element i from the second to the last in tset
for(i in 2:length(tset)){
  # calculate change in time
	dt <- tset[i] - tset[i-1]
	
	# store dummy variables
	H <- H.simu.mut[i-1]
	P <- P.simu.mut[i-1]
	
	# calculate change in population size
	dH <- ( r*H*(1-H/(K+gamma*P))-a_mut*H*P )*dt
	dP <- ( b*H*P - m*P*(1+e*P) )*dt
	
	# calculate total population size
	H.simu.mut[i] <- H + dH
	P.simu.mut[i] <- P + dP	
}
```

Check the output of your loop! Have you reached equilibrium?
```{r}

tail(H.simu.mut) # last 6 elements of H.simu.mut

```

We'll store the equilibrium values of H and P as `Hmax.mut` and `Pmax.mut`.
```{r}
# store H and P at equilibrium
Hmax.mut <- H.simu.mut[length(tset)] # host population size at the end of the simulation when partner is a mutualist
Pmax.mut <- P.simu.mut[length(tset)] # partner population size at the end of the simulation when partner is a mutualist

```

And then, we can plot our phase plane:
```{r}
# plot ZNGI for H
plot(x = dHdt.ZNGI.mut, y = Pset, # x,y = combination of host size (x) and partner size (y) at which dH/dt = 0
     type = 'l', col = Hcol, lwd = 2, las = 1, # plot aesthetics
     xlim = c(0, max(c(dHdt.ZNGI.mut, dPdt.ZNGI.mut)))/2, # x-axis limits
     xlab = 'H', ylab = 'P') # axis labels

# plot ZNGI for P
lines(x = dPdt.ZNGI.mut, y = Pset, # x, y = combination of host size (x) and partner size (y) at which dP/dt = 0
      lwd = 2, col = Pcol) # line thickness and color

# plot ZNGI at H = 0 and P = 0
abline(v = 0, lwd = 2, col = Hcol) # dH/dt = 0 when H = 0 (vertical line at x = 0)
abline(h = 0, lwd = 2, col= Pcol) # dP/dt = 0 when P = 0 (horizontal line at y = 0)

# plot community trajectory
lines(x = H.simu.mut, y = P.simu.mut, # x = host population sizes at each time point in the simulation, y = partner population sizes at each timepoint in the simulation
      col = Simucol, lwd = 2) # line color and thickness

# plot equilibrium
points(x = Hmax.mut, y = Pmax.mut, # x = equilibrium host population size, y = equilibrium partner population size
       pch = 21, col = 'black', bg = 'black') # point outline color, fill color, and shape (21 = circle)
```


We'll do the same for the case where P is a parasite.  

First, we'll calculate the ZNGIs for H and P:

```{r}
dHdt.ZNGI.par <- 1/r*(K+gamma*Pset)*(r-a_par*Pset) # H's non-zero ZNGI for case where partner is a parasite
dPdt.ZNGI.par <- m/b*(1+e*Pset) # P's non-zero ZNGI for case where partner is a parasite
```

Then, we'll simulate using a `for()` loop.
```{r}
# creating holding vectors and storing initial conditions
H.simu.par <- NaN*tset; H.simu.par[1] <- 1
P.simu.par <- NaN*tset; P.simu.par[1] <- 1

# for each element i from the second to the last in tset
for(i in 2:length(tset)){
  # calculate change in time
	dt <- tset[i] - tset[i-1]
	
	# store dummy variables
	H <- H.simu.par[i-1]
	P <- P.simu.par[i-1]
	
	# calculate change in population size
	dH <- ( r*H*(1-H/(K+gamma*P))-a_par*H*P )*dt
	dP <- ( b*H*P - m*P*(1+e*P) )*dt
	
	# calculate total population size
	H.simu.par[i] <- H + dH
	P.simu.par[i] <- P + dP	
}
```

As always, check the output of your loop. Are you at equilibrium?
```{r}
tail(H.simu.par) # last 6 elements of H.simu.par

```

Store the equilibrium points as `Hmax.par` and `Pmax.par`.

```{r}
Hmax.par <- H.simu.par[length(tset)] # host population size at the end of the simulation when partner is a parasite
Pmax.par <- P.simu.par[length(tset)] # partner population size at the end of the simulation when partner is a parasite
```

And then, plot the phase plane.
```{r}
# plot ZNGI for H
plot(x = dHdt.ZNGI.par, y = Pset, # x,y = combination of host size (x) and partner size (y) at which dH/dt = 0
     type = 'l', col = Hcol, lwd = 2, las = 1,# plot aesthetics
     xlim = c(0, max(c(dHdt.ZNGI.par, dPdt.ZNGI.par)))/2, # x-axis limits
     xlab = 'H', ylab = 'P') # axis labels

# plot ZNGI for P
lines(x = dPdt.ZNGI.par, y = Pset, # x, y = combination of host size (x) and partner size (y) at which dP/dt = 0
      lwd = 2, col = Pcol) # line thickness and color

# plot ZNGIs for H = 0 and P = 0
abline(v = 0, lwd = 2, col = Hcol) # dH/dt = 0 when H = 0 (vertical line at x = 0)
abline(h = 0, lwd = 2, col= Pcol) # dP/dt = 0 when P = 0 (horizontal line at y = 0)

# plot community trajectory
lines(x = H.simu.par, y = P.simu.par, # x = host population sizes at each time point in the simulation, y = partner population sizes at each timepoint in the simulation
      col = Simucol, lwd=2) # line color and thickness

# plot equilbrium point
points(x = Hmax.par, y = Pmax.par, # x = equilibrium host population size, y = equilibrium partner population size
       pch = 21, col = 'black', bg = 'black') # point outline color, fill color, and shape (21 = circle)
```

# PART TWO: Making this into a spatial model

## a. Background

 So far, the models that we have considered in this class are non-spatial: They imagine that all the members of all the populations that we're  considering are located in the same place, and every individual has an equal probability of interacting with every other individual.  

 However, in many cases, we might wish to have a "spatially explicit" model, i.e., one that allows for organisms to move (or propagate) across a landscape.  

 Such models have particular value in the study of invasions: They can help us understand how rapidly a new species will spread across a native landscape. (For a more positive angle, these models are also used to understand ecosystem recovery, succession, etc.)  

 The spread of a species across a landscape can be affected by its interactions with other species. For example (as we will consider today):  
	- A species that relies on a mutualistic partner may not be able to spread without its partner's presence.  
	- A species that has a parasite may spread faster (and reach higher population sizes) when that parasite is absent.  

 There are implications for both of these phenomena in applied ecology:  
	- "Co-invasion" is the process by which two non-native mutualistic partners facilitate one another's spread across a landscape.  
	- "Biocontrol" is the practice of using other living organisms to control a species of interest, for example by introducing a pathogen that decreases the growth/spread of an invasive species.  


## b. Making a spatial model

 The trickiest part about working with spatial models is figuring out how organisms should spread (and interact with one another) across space. In this lab, we'll imagine the simplest case of organisms that are spreading across a linear landscape. That may sound too simple (landscapes are 2-D, and seascapes are 3-D!), but this could be a reasonable approximation for:  
	- Species spreading along a coastline,  
	- Species spreading outward from a central area (e.g., seedlings spreading out from the edge of a forest)  

 We'll imagine that our invasion starts from the left of our linear landscape:  
  
  H   --->    --->   
 -----------------------------------------------  

 To track population dynamics, we'll divide up this landscape into a set of X chunks, and keep track of individuals in each chunk.  

 Each species will spread with a dispersal rate 'D.' We'll give each species a specific dispersal rate (`D_H` and `D_P`) so that we can ask what happens when one moves, and not the other, or when they move at different rates.  
 
We'll store those dispersal rates:

```{r}
D_H <- 0.001 # dispersal rate of the host
D_P <- 0.01 # dispersal rate of the partner
```

 Let's also assume that dispersal can only move you one "step" (either to the left or right) at a time.

 Our model now becomes:
$$
\begin{align}
\frac{dH_i}{dt} &= r H ( 1 - \frac{H}{K+\gamma P}) - a H P + D_H (H_{i-1}+H_{i+1}-2H_i) \\
\newline
\frac{dP_i}{dt} &= b H P - m P (1+eP) + D_P (P_{i-1}+P_{i+1}-2P_i) \\
\end{align}
$$

 Note that we're using the subscript $i$ to keep track of population in each of the chunks of habitat. $i = 1$ represents the populations on the left edge of the habitat; $i = X$ represents the populations on the right edge of the habitat.

## c. Simulating logistic growth with dispersal

 Let's examine how this set of equations can model the dynamics of a single species that grows logistically over time and spreads from left to right in our habitat. We can recover a logistic growth model with dispersal from the NH04 model by setting $P = 0$ and $a = 0$:

$$
\begin{align}
\frac{dH_i}{dt} = r H ( 1 - \frac{H}{K}) + D_H (H_{i-1}+H_{i+1}-2H_i)
\end{align}
$$


 To simulate, we need to set up a set of spatial coordinates:
```{r}
Xset <- seq(from = 1, to = 20) # spatial coordinates
```

 Because we have twenty 'patches' in our habitat, we need to set up ten storage variables for H_i = H_1, H_2,... H_20.  
 
 We'll use a matrix to keep things compact. Each row of this matrix represents a timepoint; each column represents a spatial location. This makes a 5000 x 20 matrix. We'll also start our simulation with H at carrying capacity at the left-most edge of the habitat, and H = 0 everywhere else.
```{r}
# create a holding matrix
H.simu3 <- matrix(data = NA, # each element of the matrix is NA
                  nrow = length(tset), ncol = length(Xset))	# number of rows = number of timesteps, number of columns = number of spatial locations

# fill initial conditions in the first row
H.simu3[1, ] <- c(K, rep(0, length(Xset)-1)) # initial host population sizes in each location: the host population starts at carrying capacity in the first patch, and is zero in all the remaining patches
```

Using the `head()` function, we can look at the matrix to double check our set up.
```{r}
head(H.simu3)
```

Now, we're ready to simulate!  

**Note:** we'll use `ifelse()` statements to calculate population sizes. This is because our computations on the left and right edges of the habitat will be slightly different. We'll set this up so that
```{r}
for (i in 2:length(tset)) {		# For each timestep
  
  # calculate change in time
  dt <- tset[i] - tset[i - 1]
  
  for (j in 1:length(Xset)) {		# For each spatial location
    
    H <- H.simu3[i - 1, j]			# Choose the correct previous population size (H = host population size in the jth patch at the previous timepoint)
    
    # calculate change in population size
    if (j == 1) { # If you're in the leftmost patch, you can only move right
      dH <- (r*H*(1 - H/K) + D_H*(H.simu3[i-1,j+1] - H) ) * dt
      # rightmost patch
    } else if (j == length(Xset)) { # If you're in the rightmost patch, you can only move left
      dH <- (r*H*(1 - H/K) + D_H*(H.simu3[i-1,j-1] - H) ) * dt
      # the middle
    } else { # If you're anywhere in the middle, you can move either right or left
      dH <- (r*H*(1-H/K) + D_H*(H.simu3[i-1,j-1] + H.simu3[i-1,j+1] - 2*H)) * dt
    }
    
    H.simu3[i, j] <- H + dH		# Compute the current population size
  }
}
```

Let's look at the beginning of our matrix to get a preview of what's happening.
```{r}
head(H.simu3) # first 6 rows of H.simu3
```

## d. Visualizing using timeseries

Let's visualize our simulation! We can do this in a number of ways. First, we can make a lot of timeseries plots. Try modifying the column selected in this code for a plot. Remember that the columns represent the patches that can be occupied by a host; therefore, you'd plot the host population size for each individual patch through time.

```{r}
plot(x = tset, y = H.simu3[,10], # x = time, y = host population size in the 10th patch
     type = 'l', lwd = 2, col = Hcol,
     xlab = 'Time', ylab = 'Host Population Size', 
     ylim = c(0, K), las = 1)  
```


### Think, Pair, Share 4

(1) What is the argument `y = H.simu3[,1]` doing? How is it subsetting the data to visualize a single line?

it is subsetting the host population size in the first patch (the first column of H.simu3) at all timepoints (all rows in H.simu3), allowing us to look at a timeseries of host population size in the first patch


 (2) Add to the following code by adding three more lines to your plot representing the population dynamics in the 5th, 10th, and 15th patches. Be sure to use different colors and add a legend so that you can distinguish them!
```{r }
# host population size in patch 1
plot(x = tset, y = H.simu3[ ,1], # x = time, y = host population size in the first patch at each timepoint (all rows of the first column of H.simu3)
     type = "l", las = 1, lwd = 2, col = Hcol, 
     xlab = "Time", ylab = "Population size",
     main = "Host population size in patches 1, 5, 10, and 15",
     ylim = c(0, 25))

# host population size in patch 5
lines(x = tset, y = H.simu3[ ,5],
      col = "seagreen3")

# host population size in patch 10
lines(x = tset, y = H.simu3[ ,10],
      col = "seagreen2")

# host population size in patch 15
lines(x = tset, y = H.simu3[ ,15],
      col = "seagreen1")

# add a legend
legend(x = 75, y = K*0.9,
       legend = c("Patch 1", "Patch 5", "Patch 10", "Patch 15"),
       lwd = 2,
       col = c(Hcol, "seagreen3", "seagreen2", "seagreen1"))
```

	(3) Describe in words what you're observing.

In the first patch, the host population starts at carrying capacity and stays at carrying capacity for the whole simulation. Over time, the host population moves into each of the other patches in the landscape, but the further away a patch is from the first patch, the longer it takes for the host to appear in that patch. Once the host appears in a patch, it quickly grows to its carrying capacity in that patch


## e. Visualizing using a heatmap

 A second way that we can visualize our findings is by using a heatmap. We can use the built in function `filled.contour()` to do this. After running the code, what do you think the `z` argument represents?
```{r}
filled.contour(x = tset, y = Xset, z = H.simu3, # x = time, y = spatial location, z = host population size at each time and location
               xlab = 'Time', ylab = 'Location') # plot labels
```

If you don't like those colors, you can use what's called a "palette" from a package of color palettes. These are made so that if you don't want to play around with palettes yourself, you can just pick one that someone's already put together. We'll use `RColorBrewer` today. Remember how to install a package, if you don't already have it? Install `RColorBrewer` if you don't already have it by running `install.packages("RColorBrewer")` in the console.  

Then, you can load in the package using `library()` or `require()`:
```{r}
library(RColorBrewer)		# Load an R colour package

display.brewer.all() # Look at the different colour palettes available
```

Once you've selected a palette, you can put it into your plot:
```{r}
filled.contour(x = tset, y = Xset, z = H.simu3, 
               nlevels = 4, 
               xlab = 'Time', ylab = 'Location',
               col = brewer.pal(4, 'Greens'))	 # 4 colors from the "Greens" palette
```

## f. Visualizing using an invasion front

 A third way is by looking at the "invasion front" -- the size of the population as a function of space -- and how it changes over time. To do this, we'll plot the host population size for each patch on the x-axis, and color our lines by timepoint (remember, there are 5000 of these).
```{r}
# plot H at time 0
plot(x = Xset, y = H.simu3[1,], # x = spatial location, y = host population size at the first timepoint (all columns of the first row of H.simu3)
     type = 'l', lwd = 2, col = Hcol, 
     xlab = 'Location', ylab = 'Host Population Size', 
     ylim = c(0, K), las = 1)
# plot H at time 1000
lines(x = Xset, y = H.simu3[1000,], # x = spatial location, y = host population size at the 1000th timepoint
      lwd = 2, col = 'seagreen3')
# plot H at time 2000
lines(x = Xset, y = H.simu3[2000,], # x = spatial location, y = host population size at the 2000th timepoint
      lwd = 2, col = 'seagreen2')
# plot H at time 3000
lines(x = Xset, y = H.simu3[3000,],# x = spatial location, y = host population size at the 3000th timepoint
      lwd = 2, col = 'seagreen1')
# add a legend
legend(x = 15, y = K*.9, 
       legend = c('Day 0', 'Day 1000', 'Day 2000', 'Day 3000'), 
       lwd = 2, 
       col = c(Hcol, 'seagreen3', 'seagreen2', 'seagreen1'),
       bg = 'white')
```

 You can see that the invasion front is moving from left to right over time. Ecologists call this an 'invasion wave,' and are often interested in measuring the shape and speed of such waves.  

 In this lab, we won't worry about making exact measurements of shape and speed, but we will compare and contrast different invasion waves to understand how the biology of species interactions affects the spatial spread of species.  

# PART THREE: Co-Invasion of Mutualists

 We now know what we'd expect if a single, logistically growing species were spreading across our landscape. But what if our logistically growing species were part of a mutualism? And, further, what if our focal species' mutualistic partner depended entirely on that species to grow? In other words, what if we had an NH04 model, with $a = a_{mut}$:  

$$
\begin{align}
\frac{dH_i}{dt} &= r H ( 1 - \frac{H}{K+\gamma P} ) - a_{mut} H P + D_H (H_{i-1}+H_{i+1}-2H_i)
\newline
\frac{dP_i}{dt} &= b H P - m P (1+eP) + D_P (P_{i-1}+P_{i+1}-2P_i)
\newline
\end{align}
$$
We'll consider three cases:  
 - Case 1: H and P move at the same rate (D_H = D_P)  
 - Case 2: H moves faster than P (D_H > D_P)  
 - Case 3: P moves faster than H (D_P > D_H)  

## a. Synchronous dispersal

Let's set the dispersal rates for H and P to be equal. This is synchronous dispersal.
```{r}
D_H <- 0.001 # host dispersal rate
D_P <- 0.001 # partner dispersal rate (same as host)
```

We'll divide up space into twenty patches again:
```{r}
Xset <- seq(from = 1, to = 20) # set of spatial locations (patches)
```

And run our simulation.  

**Note:** We're setting our initial condition in the left-most patch to be the mutualist equilibrium from part 1c.
```{r}
# create a holding matrix for H and fill initial conditions
H.simu4 <- matrix(data=NA, # each element in the matrix is NA
                  nrow = length(tset), ncol = length(Xset)) # # number of rows = number of timesteps, number of columns = number of spatial locations
H.simu4[1,] <- c(Hmax.mut,rep(0,length(Xset)-1))	# fill in the initial host population sizes in each patch: first patch starts with the host population at its equilibrium for our mutualistic partner scenario, and the rest of the patches start with no hosts

# create a holding matrix for P and fill initial conditions
P.simu4 <- matrix(data=NA, # each element in the matrix is NA
                  nrow = length(tset), ncol = length(Xset))# number of rows = number of timesteps, number of columns = number of spatial locations
P.simu4[1,] <- c(Pmax.mut,rep(0,length(Xset)-1))	# fill in the initial partner population sizes in each patch: first patch starts with the partner population at its equilibrium for our mutualistic partner scenario, and the rest of the patches start with no partners

# for each timestep
for (i in 2:length(tset)) {
  
  # calculate change in time
	dt <- tset[i] - tset[i-1]
	
	for (j in 1:length(Xset)) { # for each patch
	  
	  # store dummy variables
		P <- P.simu4[i-1, j] # P = partner population size in the jth patch at the previous timepoint
		H <- H.simu4[i-1, j] # H = host population size in the jth patch at the previous timepoint

		# calculate change in population size
		if (j == 1) { # If you're in the leftmost patch, partners and hosts can only enter/leave from the right (j+1)
			dP <- (b*H*P - m*P*(1 + e*P) + D_P*(P.simu4[i-1,j+1] - P) )*dt
			dH <- (r*H*(1 - H/(K+gamma*P)) - a_mut*H*P + D_H*(H.simu4[i-1,j+1] - H) )*dt
		} else if (j == length(Xset)) { # If you're in the rightmost patch, partners and hosts can only enter/leave from the left (j-1)
			dP <- (b*H*P - m*P*(1 + e*P) + D_P*(P.simu4[i-1,j-1] - P) ) * dt
			dH <- (r*H*(1 - H/(K+gamma*P)) - a_mut*H*P + D_H*(H.simu4[i-1,j-1] - H) )*dt
		} else { # If you're anywhere else, partners and hosts can enter/leave from both sides
			dP <- (b*H*P - m*P*(1+e*P) + D_P*(P.simu4[i-1,j-1] + P.simu4[i-1,j+1] - 2*P) )*dt
			dH <- (r*H*(1-H/(K+gamma*P)) - a_mut*H*P + D_H*(H.simu4[i-1,j-1] + H.simu4[i-1,j+1] - 2*H) )*dt
		}
		# calculate total population size and store in holding matrix
		P.simu4[i, j] <- P + dP # partner population size at ith timepoint in jth patch
		H.simu4[i, j] <- H + dH # host population size at ith timepoint in jth patch
	}
}
```

As always, check the output of your loop:
```{r}

head(H.simu4) # first 6 rows (timepoints) of H.simu4

```


And visualize our invasion wave. First, we'll plot H:
```{r}
# plot population size in each patch at time 0
plot(x = Xset, y = H.simu4[1,], # x = spatial location, y = host population size in each spatial location at the first timepoint (all columns of the first row of H.simu4)
     type = 'l', lwd = 2, col = Hcol, 
     xlab = 'Location', ylab = 'Host Population Size', 
     ylim = c(0, Hmax.mut), las = 1)
# add a line for population size in each patch at time 1000
lines(x = Xset, y = H.simu4[1000,],
      lwd = 2, col = 'seagreen3')
# add a line for population size in each patch at time 2000
lines(x = Xset, y = H.simu4[2000,],
      lwd = 2, col = 'seagreen2')
# add a line for population size in each patch at time 3000
lines(x = Xset, y = H.simu4[3000,],
      lwd = 2, col = 'seagreen1')
# add a legend
legend(x = 15, y = Hmax.mut*.9, 
       legend = c('Day 0', 'Day 1000', 'Day 2000', 'Day 3000'), 
       lwd = 2, 
       col = c(Hcol, 'seagreen3', 'seagreen2', 'seagreen1'),
       bg = 'white')
```

We can do the same for P:
```{r}
# plot population size in each patch at time 0
plot(x = Xset, y = P.simu4[1,], # x = spatial location, y = partner population size in each spatial location at the first timepoint (all columns of the first row of P.simu4)
     type = 'l', lwd = 2, col = 'lightblue4', 
     xlab = 'Location', ylab = 'Partner Population Size', 
     ylim = c(0, Pmax.mut), las = 1)
# add a line for population size in each patch at time 1000
lines(x = Xset, y = P.simu4[1000,],
      lwd = 2, col = 'lightblue3')
# add a line for population size in each patch at time 2000
lines(x = Xset, y = P.simu4[2000,],
      lwd = 2, col = 'lightblue2')
# add a line for population size in each patch at time 3000
lines(x = Xset, y = P.simu4[3000,],
      lwd = 2, col = 'lightblue1')
# add a legend
legend(x = 15, y = Pmax.mut*.9, 
       legend = c('Day 0', 'Day 1000', 'Day 2000', 'Day 3000'), 
       lwd = 2, 
       col = c('lightblue4', 'lightblue3', 'lightblue2', 'lightblue1'),
       bg = 'white')
```

If we wanted to get really crazy, we could put everything on the same graph:
```{r}
plot(x = Xset, y = H.simu4[1,], # host population sizes in each patch at the first timepoint
     type = 'l', lwd = 2, col = Hcol, 
     xlab = 'Location',ylab = 'Host or Partner Population Size', 
     main = 'Case 1: Synchronous dispersal',
     ylim=c(0,Hmax.mut), las=1)
lines(x = Xset, y = H.simu4[1000,],# host population sizes in each patch at timepoint 1000
      lwd = 2, col = 'seagreen3')
lines(x = Xset, y = H.simu4[2000,],# host population sizes in each patch at timepoint 2000
      lwd = 2, col = 'seagreen2')
lines(x = Xset, y = H.simu4[3000,],# host population sizes in each patch at timepoint 3000
      lwd = 2, col = 'seagreen1')
lines(x = Xset, y = P.simu4[1,], # partner population sizes in each patch at the first timepoint
      lwd = 2, col = 'lightblue4')
lines(x = Xset, y = P.simu4[1000,],# partner population sizes in each patch at timepoint 1000
      lwd = 2, col = 'lightblue3')
lines(x = Xset, y = P.simu4[2000,], # partner population sizes in each patch at timepoint 2000
      lwd = 2, col = 'lightblue2')
lines(x = Xset, y = P.simu4[3000,],# partner population sizes in each patch at timepoint 3000
       lwd = 2, col = 'lightblue1')
legend(x = 14, y = Hmax.mut*.9, 
       legend = c('Day 0, H','Day 1000, H','Day 2000, H','Day 3000, H',
                'Day 0, P','Day 1000, P','Day 2000, P','Day 3000, P'), 
       lwd = 2, 
       col = c(Hcol,'seagreen3','seagreen2','seagreen1',
             'lightblue4','lightblue3','lightblue2','lightblue1'),
       bg = 'white')
```

If we compare the results with the un-partnered host (from Part 2, above), we can see that, while the population sizes are larger with the partner, the rate of spread of the host didn't really change (e.g., the host is reaching patch 15 by about day 3000 in both cases):
```{r}
# synchronous dispersal where D_H = D_P = 0.001
plot(x = Xset, y = H.simu4[1,], # host population sizes in each patch at the first timepoint
     type = 'l', lwd = 2, col = Hcol, 
     xlab = 'Location', ylab = 'Host Population Size', 
     ylim = c(0, Hmax.mut), las = 1,
     main = expression("Synchronous dispersal: D"[H]*" = D"[P]*" = 0.001"))
lines(x = Xset, y = H.simu4[1000,], # host population sizes in each patch at timepoint 1000
      lwd = 2, col = 'seagreen3')
lines(x = Xset, y = H.simu4[2000,],# host population sizes in each patch at timepoint 2000
      lwd = 2, col = 'seagreen2')
lines(x = Xset, y = H.simu4[3000,],# host population sizes in each patch at timepoint 3000
      lwd = 2, col = 'seagreen1')
legend(x = 15, y = Hmax.mut*.9, 
       legend = c('Day 0','Day 1000','Day 2000','Day 3000'), 
       lwd = 2, 
       col = c(Hcol, 'seagreen3', 'seagreen2', 'seagreen1'),
       bg = 'white')

# dispersal of species H without a mutualist species P
plot(x = Xset, y = H.simu3[1,], # host population sizes in each patch at the first timepoint
     type = 'l', lwd = 2, col = Hcol, 
     xlab = 'Location', ylab = 'Host Population Size', 
     ylim = c(0, Hmax.mut), las = 1,
     main = "Dispersal without a mutualist")
lines(x = Xset, y = H.simu3[1000,], # host population sizes in each patch at timepoint 1000
      lwd = 2, col = 'seagreen3')
lines(x = Xset, y = H.simu3[2000,],# host population sizes in each patch at timepoint 2000
      lwd = 2, col = 'seagreen2')
lines(x = Xset, y = H.simu3[3000,],# host population sizes in each patch at timepoint 3000
      lwd = 2, col = 'seagreen1')
legend(x = 15, y = Hmax.mut*0.99, 
       legend = c('Day 0','Day 1000','Day 2000','Day 3000'), 
       lwd = 2, 
       col = c(Hcol, 'seagreen3', 'seagreen2', 'seagreen1'),
       bg = 'white')
```

We can also see this by plotting the invasion front at the same timepoint on the same set of axes. CAREFUL! This only works if you've used the same tset for both your simulations!
```{r}
plot(x = Xset, y = H.simu4[1000,], # host population sizes in each patch at timepoint 1000 for simulation with mutualistic partner
     type = 'l', lwd = 2, col = Hcol, 
     xlab = 'Location', ylab = 'Host Population Size',
     main = 'Host population size across space at t = 1000',
     ylim = c(0, Hmax.mut), las = 1)
lines(x = Xset, y = H.simu3[1000,], # host population sizes in each patch at timepoint 1000 for simulation with no partner
      lwd = 2, col = 'seagreen3')
legend(x = 12, y = Hmax.mut*.99, 
       legend = c('w/ mutualist', 'w/o mutualist'),
       lwd = 2, 
       col = c(Hcol, 'seagreen3'),
       bg = 'white')
```

## b. Host-first dispersal

Let's set the dispersal rates at

```{r}
D_H <- 0.01 # host dispersal rate
D_P <- 0.001 # partner dispersal rate
```


### Think, Pair, Share 5
(1) Create new simulation storage vectors (`H.simu5` and `P.simu5`), and run a simulation using these dispersal rates. **HINT:** Copy/paste from Part 3A, above.

```{r}
# create a holding matrix for H and fill initial conditions
H.simu5 <- matrix(data=NA, # each element in the matrix is NA
                  nrow = length(tset), ncol = length(Xset)) # number of rows = number of timesteps, number of columns = number of spatial locations
H.simu5[1,] <- c(Hmax.mut,rep(0,length(Xset)-1))	# fill in the initial host population sizes in each patch: first patch starts with the host population at its equilibrium for our mutualistic partner scenario, and the rest of the patches start with no hosts

# create a holding matrix for P and fill initial conditions
P.simu5 <- matrix(data=NA, # each element in the matrix is NA
                  nrow = length(tset), ncol = length(Xset)) # number of rows = number of timesteps, number of columns = number of spatial locations
P.simu5[1,] <- c(Pmax.mut,rep(0,length(Xset)-1))# fill in the initial partner population sizes in each patch: first patch starts with the partner population at its equilibrium for our mutualistic partner scenario, and the rest of the patches start with no partners

# for each timestep
for (i in 2:length(tset)) {
  
  # calculate change in time
	dt <- tset[i] - tset[i-1]
	
	for (j in 1:length(Xset)) { # for each patch
	  
	  # store placeholder variables
		P <- P.simu5[i-1, j] # P = partner population size in the jth patch at the previous timepoint
		H <- H.simu5[i-1, j] # H = host population size in the jth patch at the previous timepoint

		# calculate change in population size
		if (j == 1) { # If you're in the leftmost patch, partners and hosts can only enter/leave from the right (j+1)
			dP <- (b*H*P - m*P*(1 + e*P) + D_P*(P.simu5[i-1,j+1] - P) )*dt
			dH <- (r*H*(1 - H/(K+gamma*P)) - a_mut*H*P + D_H*(H.simu5[i-1,j+1] - H) )*dt
		} else if (j == length(Xset)) { # If you're in the rightmost patch, partners and hosts can only enter/leave from the left (j-1)
			dP <- (b*H*P - m*P*(1 + e*P) + D_P*(P.simu5[i-1,j-1] - P) ) * dt
			dH <- (r*H*(1 - H/(K+gamma*P)) - a_mut*H*P + D_H*(H.simu5[i-1,j-1] - H) )*dt
		} else { # If you're anywhere else, partners and hosts can enter/leave from both sides
			dP <- (b*H*P - m*P*(1+e*P) + D_P*(P.simu5[i-1,j-1] + P.simu5[i-1,j+1] - 2*P) )*dt
			dH <- (r*H*(1-H/(K+gamma*P)) - a_mut*H*P + D_H*(H.simu5[i-1,j-1] + H.simu5[i-1,j+1] - 2*H) )*dt
		}
		# calculate total population size and store in holding matrix
		P.simu5[i, j] <- P + dP # partner population size at ith timepoint in jth patch
		H.simu5[i, j] <- H + dH # host population size at ith timepoint in jth patch
	}
}

# check
head(P.simu5) # first 6 rows
```



(2) Visualize the invasion fronts of the host and the partner at t = 1, t = 1000, t = 2000, and t = 3000 (as we have previously).

```{r}
# plot population size in each patch at time 0
plot(x = Xset, y = H.simu5[1,], 
     type = 'l', lwd = 2, col = Hcol, 
     xlab = 'Location', ylab = 'Host Population Size', 
     main = 'Case 2: Host-first dispersal',
     ylim = c(0, Hmax.mut), las = 1)
# add a line for population size in each patch at time 1000
lines(x = Xset, y = H.simu5[1000,],
      lwd = 2, col = 'seagreen3')
# add a line for population size in each patch at time 2000
lines(x = Xset, y = H.simu5[2000,],
      lwd = 2, col = 'seagreen2')
# add a line for population size in each patch at time 3000
lines(x = Xset, y = H.simu5[3000,],
      lwd = 2, col = 'seagreen1')
# add a legend
legend(x = 15, y = Hmax.mut*.9, 
       legend = c('Day 0', 'Day 1000', 'Day 2000', 'Day 3000'), 
       lwd = 2, 
       col = c(Hcol, 'seagreen3', 'seagreen2', 'seagreen1'),
       bg = 'white')

# plot population size in each patch at time 0
plot(x = Xset, y = P.simu5[1,], 
     type = 'l', lwd = 2, col = 'lightblue4', 
     xlab = 'Location', ylab = 'Partner Population Size', 
     main = 'Case 2: Host-first dispersal',
     ylim = c(0, Pmax.mut), las = 1)
# add a line for population size in each patch at time 1000
lines(x = Xset, y = P.simu5[1000,],
      lwd = 2, col = 'lightblue3')
# add a line for population size in each patch at time 2000
lines(x = Xset, y = P.simu5[2000,],
      lwd = 2, col = 'lightblue2')
# add a line for population size in each patch at time 3000
lines(x = Xset, y = P.simu5[3000,],
      lwd = 2, col = 'lightblue1')
# add a legend
legend(x = 15, y = Pmax.mut*.9, 
       legend = c('Day 0', 'Day 1000', 'Day 2000', 'Day 3000'), 
       lwd = 2, 
       col = c('lightblue4', 'lightblue3', 'lightblue2', 'lightblue1'),
       bg = 'white')
```

(3) Modify the code from the end of part 3a to compare the location of the Host's invasion front on Day 1000 for (a) the no-mutualist simulation, (b) the same-speed mutualist simulation, and (c) this host-faster simulation.
```{r}
# synchronous dispersal with mutualist
plot(x = Xset, y = H.simu4[1000,], # host population size in each patch at timepoint 1000 from simulation with mutualistic partner that disperses at the same rate as the host
     type = 'l', lwd = 2, col = Hcol, 
     xlab = 'Location', ylab = 'Host Population Size',
     main = 'Host population size across space at t = 1000',
     ylim = c(0, Hmax.mut), las = 1)
# no mutualist simulation
lines(x = Xset, y = H.simu3[1000,],# host population size in each patch at timepoint 1000 from simulation with no partner
      lwd = 2, col = 'seagreen3')
# host-faster simulation
lines(x = Xset, y = H.simu5[1000,],# host population size in each patch at timepoint 1000 from simulation with mutualistic partner that disperses at a slower rate than the host
      lwd = 2, col = 'blue')
legend(x = 12, y = Hmax.mut*.99, 
       legend = c('w/ mutualist', 'w/o mutualist', 'host-faster'),
       lwd = 2, 
       col = c(Hcol, 'seagreen3', 'blue'),
       bg = 'white')
```


(4) Compare the location of the Partner's invasion front on Day 1000 for (a) the same-speed mutualist simulation, and (b) this host-faster simulation.

```{r}
# synchronous dispersal with host
plot(x = Xset, y = P.simu4[1000,], # partner population size in each patch at timepoint 1000 from simulation with mutualistic partner that disperses at the same rate as the host
     type = 'l', lwd = 2, col = Pcol, 
     xlab = 'Location', ylab = 'Partner Population Size',
     main = 'Mutualist population size across space at t = 1000',
     ylim = c(0, Hmax.mut), las = 1)
# host faster than mutualist
lines(x = Xset, y = P.simu5[1000,], # partner population size in each patch at timepoint 1000 from simulation with mutualistic partner that disperses at a slower rate than the host
      lwd = 2, col = 'blue')
legend(x = 11, y = Hmax.mut*.99, 
       legend = c('same-speed mutualist', 'host-faster'),
       lwd = 2, 
       col = c(Pcol, 'blue'),
       bg = 'white')
```




(5) Describe your observations using biological/ecological terms.

When the mutualist and host have the same dispersal rate, the invasion front of the host is similar to its invasion front when the mutualist is absent. When the host has a higher dispersal rate, the host moves through the landscape faster, and the mutualist also moves faster (even though we didn't increase its dispersal rate). The mutualist's invasion front also lags slightly behind that of the host. All this suggests that it is easier for the mutualist to spread across the landscape when it is moving into patches where the host has already become established.


## c. Partner-first dispersal

Let's set the dispersal rates at:
```{r}
D_H <- 0.001 # host dispersal rate
D_P <- 0.1 # partner dispersal rate
```

### Think, Pair, Share 6
(1) Run a simulation for these dispersal values. Remember to store your results using new variables!

```{r}
# create a holding matrix for H and fill initial conditions
H.simu6 <- matrix(data=NA, # each element in the matrix is NA
                  nrow = length(tset), ncol = length(Xset)) # number of rows = number of timesteps, number of columns = number of spatial locations
H.simu6[1,] <- c(Hmax.mut,rep(0,length(Xset)-1))	# fill in the initial host population sizes in each patch: first patch starts with the host population at its equilibrium for our mutualistic partner scenario, and the rest of the patches start with no hosts

# create a holding matrix for P and fill initial conditions
P.simu6 <- matrix(data=NA, # each element in the matrix is NA
                  nrow = length(tset), ncol = length(Xset)) # number of rows = number of timesteps, number of columns = number of spatial locations
P.simu6[1,] <- c(Pmax.mut,rep(0,length(Xset)-1)) # fill in the initial partner population sizes in each patch: first patch starts with the partner population at its equilibrium for our mutualistic partner scenario, and the rest of the patches start with no partners

# for each timestep
for (i in 2:length(tset)) {
  
  # calculate change in time
	dt <- tset[i] - tset[i-1]
	
	for (j in 1:length(Xset)) { # for each patch
	  
	  # store placeholder variables
		P <- P.simu6[i-1, j] # P = partner population size in the jth patch at the previous timepoint
		H <- H.simu6[i-1, j] # H = host population size in the jth patch at the previous timepoint

		# calculate change in population size
		if (j == 1) { # If you're in the leftmost patch, partners and hosts can only enter/leave from the right (j+1)
			dP <- (b*H*P - m*P*(1 + e*P) + D_P*(P.simu6[i-1,j+1] - P) )*dt
			dH <- (r*H*(1 - H/(K+gamma*P)) - a_mut*H*P + D_H*(H.simu6[i-1,j+1] - H) )*dt
		} else if (j == length(Xset)) { # If you're in the rightmost patch, partners and hosts can only enter/leave from the left (j-1)
			dP <- (b*H*P - m*P*(1 + e*P) + D_P*(P.simu6[i-1,j-1] - P) ) * dt
			dH <- (r*H*(1 - H/(K+gamma*P)) - a_mut*H*P + D_H*(H.simu6[i-1,j-1] - H) )*dt
		} else { # If you're anywhere else, partners and hosts can enter/leave from both sides
			dP <- (b*H*P - m*P*(1+e*P) + D_P*(P.simu6[i-1,j-1] + P.simu6[i-1,j+1] - 2*P) )*dt
			dH <- (r*H*(1-H/(K+gamma*P)) - a_mut*H*P + D_H*(H.simu6[i-1,j-1] + H.simu6[i-1,j+1] - 2*H) )*dt
		}
		# calculate total population size and store in holding matrix
		P.simu6[i, j] <- P + dP
		H.simu6[i, j] <- H + dH
	}
}

# check
head(P.simu6)
```


(2) Visualize the invasion fronts of host and partner at t = 0, t = 1000, t = 2000, and t = 3000

```{r}
# plot population size in each patch at time 0
plot(x = Xset, y = H.simu6[1,], # host population size in each patch at the first timepoint
     type = 'l', lwd = 2, col = Hcol, 
     xlab = 'Location', ylab = 'Host Population Size', 
     main = 'Case 3: Partner-first dispersal',
     ylim = c(0, Hmax.mut), las = 1)
# add a line for population size in each patch at time 1000
lines(x = Xset, y = H.simu6[1000,],
      lwd = 2, col = 'seagreen3')
# add a line for population size in each patch at time 2000
lines(x = Xset, y = H.simu6[2000,],
      lwd = 2, col = 'seagreen2')
# add a line for population size in each patch at time 3000
lines(x = Xset, y = H.simu6[3000,],
      lwd = 2, col = 'seagreen1')
# add a legend
legend(x = 15, y = Hmax.mut*.9, 
       legend = c('Day 0', 'Day 1000', 'Day 2000', 'Day 3000'), 
       lwd = 2, 
       col = c(Hcol, 'seagreen3', 'seagreen2', 'seagreen1'),
       bg = 'white')

# plot population size in each patch at time 0
plot(x = Xset, y = P.simu6[1,], # partner population size in each patch at the first timepoint
     type = 'l', lwd = 2, col = 'lightblue4', 
     xlab = 'Location', ylab = 'Partner Population Size', 
     main = 'Case 3: Partner-first dispersal',
     ylim = c(0, Pmax.mut), las = 1)
# add a line for population size in each patch at time 1000
lines(x = Xset, y = P.simu6[1000,],
      lwd = 2, col = 'lightblue3')
# add a line for population size in each patch at time 2000
lines(x = Xset, y = P.simu6[2000,],
      lwd = 2, col = 'lightblue2')
# add a line for population size in each patch at time 3000
lines(x = Xset, y = P.simu6[3000,],
      lwd = 2, col = 'lightblue1')
# add a legend
legend(x = 15, y = Pmax.mut*.9, 
       legend = c('Day 0', 'Day 1000', 'Day 2000', 'Day 3000'), 
       lwd = 2, 
       col = c('lightblue4', 'lightblue3', 'lightblue2', 'lightblue1'),
       bg = 'white')
```


(3) Compare the host's invasion front on Day 1000 for (a) D_H = D_P, (b) D_H > D_P, and (c) D_H < D_P (this simulation).

```{r}
# synchronous dispersal with mutualist
plot(x = Xset, y = H.simu4[1000,], # host population size in each patch at timepoint 1000 from simulation with mutualistic partner that disperses at the same rate as the host
     type = 'l', lwd = 2, col = Hcol, 
     xlab = 'Location', ylab = 'Host Population Size',
     main = 'Host population size across space at t = 1000',
     ylim = c(0, Hmax.mut), las = 1)
# no mutualist simulation
lines(x = Xset, y = H.simu3[1000,],# host population size in each patch at timepoint 1000 from simulation with no partner
      lwd = 2, col = 'seagreen3')
# host-faster simulation
lines(x = Xset, y = H.simu5[1000,],# host population size in each patch at timepoint 1000 from simulation with mutualistic partner that disperses at a slower rate than the host
      lwd = 2, col = 'blue')
# host-slower simulation
lines(x = Xset, y = H.simu6[1000,],# host population size in each patch at timepoint 1000 from simulation with mutualistic partner that disperses at a faster rate than the host
      lwd = 2, col = "purple",
      lty = 2) # make this line dashed
legend(x = 12, y = Hmax.mut*.99, 
       legend = c('w/ mutualist', 'w/o mutualist', 'host-faster', 'host-slower'),
       lwd = 2, 
       lty = c(1, 1, 1, 2),
       col = c(Hcol, 'seagreen3', 'blue', 'purple'),
       bg = 'white')
```


(4) Compare the partner's invasion front on Day 1000 for (a) D_H = D_P, (b) D_H > D_P, and (c) D_H < D_P (this simulation).

```{r}
# synchronous dispersal with host
plot(x = Xset, y = P.simu4[1000,], # partner population size in each patch at timepoint 1000 from simulation with mutualistic partner that disperses at the same rate as the host
     type = 'l', lwd = 2, col = Pcol, 
     xlab = 'Location', ylab = 'Host Population Size',
     main = 'Mutualist population size across space at t = 1000',
     ylim = c(0, Hmax.mut), las = 1)
# host faster than mutualist
lines(x = Xset, y = P.simu5[1000,], # partner population size in each patch at timepoint 1000 from simulation with mutualistic partner that disperses at a slower rate than the host
      lwd = 2, col = 'blue')
# host slower than mutualist
lines(x = Xset, y = P.simu6[1000,], # partner population size in each patch at timepoint 1000 from simulation with mutualistic partner that disperses at a faster rate than the host
      lwd = 2, col = 'purple', lty = 2)
legend(x = 11, y = Hmax.mut*.99, 
       legend = c('same-speed mutualist', 'host-faster', 'host-slower'),
       lwd = 2, 
       lty = c(1, 1, 1, 2),
       col = c(Pcol, 'blue', 'purple'),
       bg = 'white')
```


(5) Describe your findings in words.


Making the dispersal rate of the mutualist higher but keeping the dispersal rate of the host at the original lower value has minimal effects on the invasion fronts compared to the synchronous scenario (when both the mutualist and host had a low dispersal rate). This, together with the results of the host-faster scenario above, suggests that the rate at which the host and mutualist spread across the landscape is set by the rate at which the host disperses (the mutualist can't survive without the host, so the host needs to already be in a patch in order for the mutualist to invade that patch)



